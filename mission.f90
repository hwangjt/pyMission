! This file contains functions (to be wrapped with f2py) which are
! used with pyMission


subroutine getFinDiffCoef(M, N, x0, nCoord, coord, d)
  ! subroutine used to compute the finite element coefficients
  ! that are multiplied with discrete values to provide estimates
  ! of the derivatives
  ! these coefficients can be generated for uniform and non-uniform
  ! spacings

  implicit none

  !f2py intent(in) M, N, x0, nCoord, coord
  !f2py intent(out) d
  !f2py depend(M,N) d
  !f2py depend(nCoord) coord

  ! input/output
  integer, intent(in) :: M, N
  double precision, intent(in) :: x0
  integer, intent(in) :: nCoord
  double precision, dimension(0:nCoord), intent(in) :: coord
  double precision, dimension(0:M,0:N-1,0:N-1), intent(out) :: d

  ! variable initialization
  integer :: i = 0, j = 0, k = 0
  double precision :: c1 = 0.0, c2 = 0.0, c3 = 0.0

  do i = 0, M
     do j = 0, N-1
        do k = 0, N-1
           d(i,j,k) = 0.0
        end do
     end do
  end do

  d(0,0,0) = 1.0
  c1 = 1.0

  do j = 1, N-1
     c2 = 1.0

     do k = 0, j-1
        c3 = coord(j)-coord(k)
        c2 = c2*c3
        
        do i = 0, min(j,M)
           if (i == 0) then
              d(i,j,k) = ((coord(j)-x0)*d(i,j-1,k))/c3
           else
              d(i,j,k) = ((coord(j)-x0)*d(i,j-1,k)-i*d(i-1,j-1,k))/c3
           end if
        end do
     end do

     do i = 0, min(j,M)
        if (i == 0) then
           d(i,j,j) = -(c1/c2)*(coord(j-1)-x0)*d(i,j-1,j-1)
        else
           d(i,j,j) = (c1/c2)*(i*d(i-1,j-1,j-1)-(coord(j-1)-x0)*d(i,j-1,j-1))
        end if
     end do
     
     c1 = c2
  end do

end subroutine getFinDiffCoef

subroutine getDerivatives(numSeg, x, h, v, dv, gamma, dGamma, d2Gamma)
  ! subroutine used to compute dv/dx, gamma, dgamma/dx, d2gamma/dx2
  ! using approximations to dh/dx, d2h/dx2, d3h/dx3 generated by
  ! multiplying discrete values of h with the finite difference
  ! coefficients generated by the subroutine getFinDiffCoeff

  implicit none
  
  !f2py intent(in) numSeg
  !f2py intent(in) x, h, v
  !f2py intent(out) dv, gamma, dGamma, d2Gamma
  !f2py depend(numSeg) x, h, v, gamma, dGamma, d2Gamma

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, v
  double precision, dimension(0:numSeg-1), intent(out) :: dv, gamma, dGamma, d2Gamma
  double precision, dimension(0:numSeg-1) :: dh, d2h, d3h
  integer :: i = 0
  double precision, dimension(0:1,0:2,0:2) :: coeffs1ends
  double precision, dimension(0:2,0:3,0:3) :: coeffs2ends
  double precision, dimension(0:3,0:4,0:4) :: coeffs3ends
  double precision, dimension(0:2,0:2,0:2) :: coeffs12
  double precision, dimension(0:3,0:4,0:4) :: coeffs3

  ! use forward difference for the first 2 control points
  do i = 0,1
     call getFinDiffCoef(1,3,x(i),2,x(i:i+2),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i:i+2))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i:i+2))

     call getFinDiffCoef(2,4,x(i),3,x(i:i+3),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i:i+3))

     call getFinDiffcoef(3,5,x(i),4,x(i:i+4),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i:i+4))
  enddo

  ! use central difference for the 3rd to the 3rd-to-last
  ! control points
  do i = 2,numSeg-3
     call getFinDiffCoef(2,3,x(i),2,x(i-1:i+1),coeffs12)
     dh(i) = dot_product(coeffs12(1,2,0:2),h(i-1:i+1))
     dv(i) = dot_product(coeffs12(1,2,0:2),v(i-1:i+1))
     d2h(i) = dot_product(coeffs12(2,2,0:2),h(i-1:i+1))

     call getFinDiffCoef(3,5,x(i),4,x(i-2:i+2),coeffs3)
     d3h(i) = dot_product(coeffs3(3,4,0:4),h(i-2:i+2))
  enddo

  ! use backwards difference for the last 2 control points
  do i = numSeg-2,numSeg-1
     call getFinDiffCoef(1,3,x(i),2,x(i-2:i),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i-2:i))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i-2:i))

     call getFinDiffCoef(2,4,x(i),3,x(i-3:i),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i-3:i))
     
     call getFinDiffCoef(3,5,x(i),4,x(i-4:i),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i-4:i))
  enddo

  ! compute gamma, dgamma/dx, and d2gamma/dx2 using dh/dx,
  ! d2h/dx2, and d3h/dx3
  gamma = atan(dh)
  dGamma = d2h/(dh*dh+1)
  d2Gamma = (((dh*dh+1)*d3h-2*dh*d2h*d2h)/((dh*dh+1)*(dh*dh+1)))

end subroutine getDerivatives

subroutine getDDerivatives(numSeg, x, h, v, ddhdh, ddvdv, dgammadh, dd2hdh, &
     ddGammadh, dd3hdh, dd2Gammadh)
  ! computes the derivatives of dh/dx, dv/dx, gamma, d2h/dx2, dgamma/dx,
  ! d3h/dx3, d2gamma/dx2 with respect to h and v
  
  !f2py intent(in) numSeg
  !f2py intent(in) x, h, v
  !f2py intent(out) ddhdh, ddvdv, dgammadh, dd2hdh, ddGammadh, dd3hdh, dd2Gammadh
  !f2py depend(numSeg) x, h, v, ddhdh, ddvdv, dgammadh, dd2hdh, ddGammadh, dd3hdh, dd2Gammadh

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, v
  double precision, dimension(0:numSeg-1,0:2), intent(out) :: ddhdh, ddvdv, dgammadh
  double precision, dimension(0:numSeg-1,0:3), intent(out) :: dd2hdh, ddGammadh
  double precision, dimension(0:numSeg-1,0:4), intent(out) :: dd3hdh, dd2Gammadh
  
  integer :: i = 0
  double precision, dimension(0:numSeg-1) :: dh, dv, d2h, d3h
  double precision, dimension(0:1,0:2,0:2) :: coeffs1ends
  double precision, dimension(0:2,0:3,0:3) :: coeffs2ends
  double precision, dimension(0:3,0:4,0:4) :: coeffs3ends
  double precision, dimension(0:2,0:2,0:2) :: coeffs12
  double precision, dimension(0:3,0:4,0:4) :: coeffs3
  
  
  do i = 0,1
     call getFinDiffCoef(1,3,x(i),2,x(i:i+2),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i:i+2))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i:i+2))
     do j = 0,2
        ddhdh(i,j) = coeffs1ends(1,2,j)
        ddvdv(i,j) = coeffs1ends(1,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
     enddo

     call getFinDiffCoef(2,4,x(i),3,x(i:i+3),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i:i+3))
     do j = 0,3
        dd2hdh(i,j) = coeffs2ends(2,3,j)
     enddo

     do j = 0,2
        ddGammadh(i,j) = (1/(dh(i)**2+1))*dd2hdh(i,j) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo
     ddGammadh(i,3) = (1/(dh(i)**2+1))*dd2hdh(i,j)

     call getFinDiffCoef(3,5,x(i),4,x(i:i+4),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i:i+4))
     do j = 0,4
        dd3hdh(i,j) = coeffs3ends(3,4,j)
     enddo

     do j = 0,2
        dd2Gammadh(i,j) = 2*dh(i)*ddhdh(i,j)*(d3h(i)/(dh(i)**2+1)**2) &
             +(1/(dh(i)**2+1))*dd3hdh(i,j) &
             -4*dh(i)*ddhdh(i,j)*((dh(i)**2+1)*d3h(i))/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
     dd2Gammadh(i,3) = (1/(dh(i)**2+1))*dd3hdh(i,3) &
          -4*dh(i)*dd2hdh(i,3)*d2h(i)/(dh(i)**2+1)**2
     dd2Gammadh(i,4) = (1/(dh(i)**2+1))*dd3hdh(i,4)
  enddo

  do i = 2,numSeg-3
     call getFinDiffCoef(2,3,x(i),2,x(i-1:i+1),coeffs12)
     dh(i) = dot_product(coeffs12(1,2,0:2),h(i-1:i+1))
     dv(i) = dot_product(coeffs12(1,2,0:2),v(i-1:i+1))
     d2h(i) = dot_product(coeffs12(2,2,0:2),h(i-1:i+1))
     do j = 0,2
        ddhdh(i,j) = coeffs12(1,2,j)
        ddvdv(i,j) = coeffs12(1,2,j)
        dd2hdh(i,j) = coeffs12(2,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
        ddGammadh(i,j) = (1/(dh(i)**2+1))*dd2hdh(i,j) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo

     call getFinDiffCoef(3,5,x(i),4,x(i-2:i+2),coeffs3)
     d3h(i) = dot_product(coeffs3(3,4,0:4),h(i-2:i+2))
     do j = 0,4
        dd3hdh(i,j) = coeffs3(3,4,j)
     enddo

     dd2Gammadh(i,0) = (1/(dh(i)**2+1))*dd3hdh(i,0)
     do j = 0,2
        dd2Gammadh(i,j+1) = 2*dh(i)*ddhdh(i,j)*d3h(i)/(dh(i)**2+1)**2 &
             +(1/(dh(i)**2+1))*dd3hdh(i,j+1) &
             -4*dh(i)*ddhdh(i,j)*(dh(i)**2+1)*d3h(i)/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
     dd2Gammadh(i,4) = (1/(dh(i)**2+1))*dd3hdh(i,4)

  enddo

  do i = numSeg-2,numSeg-1
     call getFinDiffCoef(1,3,x(i),2,x(i-2:i),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i-2:i))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i-2:i))
     do j = 0,2
        ddhdh(i,j) = coeffs1ends(1,2,j)
        ddvdv(i,j) = coeffs1ends(1,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
     enddo

     call getFinDiffCoef(2,4,x(i),3,x(i-3:i),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i-3:i))
     do j = 0,3
        dd2hdh(i,j) = coeffs2ends(2,3,j)
     enddo

     ddGammadh(i,0) = (1/(dh(i)**2+1))*dd2hdh(i,0)
     do j = 0,2
        ddGammadh(i,j+1) = (1/(dh(i)**2+1))*dd2hdh(i,j+1) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo

     call getFinDiffCoef(3,5,x(i),4,x(i-4:i),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i-4:i))
     do j = 0,4
        dd3hdh(i,j) = coeffs3ends(3,4,j)
     enddo

     dd2Gammadh(i,0) = (1/(dh(i)**2+1))*dd3hdh(i,0)
     dd2Gammadh(i,1) = (1/(dh(i)**2+1))*dd3hdh(i,1) &
          -4*dh(i)*dd2hdh(i,0)*d2h(i)/(dh(i)**2+1)**2
     do j = 0,2
        dd2Gammadh(i,j+2) = 2*dh(i)*ddhdh(i,j)*d3h(i)/(dh(i)**2+1)**2 &
             +(1/(dh(i)**2+1))*dd3hdh(i,j+2) &
             -4*dh(i)*ddhdh(i,j)*(dh(i)**2+1)*d3h(i)/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j+1)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
  enddo
end subroutine getDDerivatives

subroutine getAlpha(numSeg, eta, CL, alpha)
  ! compute alpha as defined by the linear aerodynamics

  !f2py intent(in) numSeg
  !f2py intent(in) eta, CL
  !f2py intent(out) alpha
  !f2py depend(numSeg) eta, CL, alpha

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: eta, CL
  double precision, dimension(0:numSeg-1), intent(out) :: alpha

  alpha = (1/4.24)*(CL-0.26-0.27*eta)

end subroutine getAlpha

subroutine get_alpha(numElem, CL, eta, alpha)
  !f2py intent(in) numElem
  !f2py intent(in) CL, eta
  !f2py intent(out) alpha
  !f2py depend(numElem) CL, eta, alpha

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: CL, eta
  double precision, dimension(0:numElem), intent(out) :: alpha

  alpha = (1/4.24)*(CL-0.26-0.27*eta)

end subroutine get_alpha

subroutine getDAlpha(numSeg, alpha, eta, CL, deta, dCL)
  ! compute the derivatives of alpha wrt alpha, eta, and CL

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CL
  !f2py intent(out) deta, dCL
  !f2py depend(numSeg) alpha, eta, CL, deta, dCL

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CL
  double precision, dimension(0:numSeg-1), intent(out) :: deta, dCL

  integer :: i = 0

  do i = 0,numSeg-1
     deta(i) = -0.27/4.24
     dCL(i) = 1/4.24
  enddo

end subroutine getDAlpha

subroutine get_CD(numElem, AR, e, CL, CD)
  ! compute CD using simple drag polar

  !f2py intent(in) numElem
  !f2py intent(in) AR, e
  !f2py intent(in) CL
  !f2py intent(out) CD
  !f2py depend(numElem) CL, CD

  ! Input/Output
  integer, intent(in) :: numElem
  double precision, intent(in) :: AR, e
  double precision, dimension(0:numElem), intent(in) :: CL
  double precision, dimension(0:numElem), intent(out) :: CD
  
  double precision, parameter :: PI = 3.14159265359

  CD = (0.018 + CL**2/(PI*AR*e))

end subroutine get_CD

subroutine getDCD(numSeg, AR, e, CL, CD, dAR, de, dCL)
  ! compute the derivatives CD wrt AR, e, CL, and CD

  !f2py intent(in) numSeg
  !f2py intent(in) AR, e
  !f2py intent(in) CL, CD
  !f2py intent(out) dAR, de, dCL
  !f2py depend(numSeg) CL, CD, dAR, de, dCL

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, intent(in) :: AR, e
  double precision, dimension(0:numSeg-1), intent(in) :: CL, CD
  double precision, dimension(0:numSeg-1), intent(out) :: dAR, de, dCL
  
  integer :: i = 0
  double precision, parameter :: PI = 3.14159254359

  do i = 0,numSeg-1
     dAR(i) = -CL(i)**2/(PI*e*AR**2)
     de(i) = -CL(i)**2/(PI*AR*e**2)
     dCL(i) = 2*CL(i)/(PI*AR*e)
  enddo

end subroutine getDCD

subroutine get_Eta(numElem, CM, alpha, eta)
  ! compute eta (tail rotation angle)

  !f2py intent(in) numSeg
  !f2py intent(in) CM, alpha
  !f2py intent(out) eta
  !f2py depend(numElem) CM, alpha, eta

  !Input/Output
  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: CM, alpha
  double precision, dimension(0:numElem), intent(out) :: eta

  eta = (1/1.06)*(0.63*alpha - CM)

end subroutine get_Eta

subroutine getDEta(numSeg, alpha, eta, CM, dalpha, dCM)
  ! compute the derivatives of eta wrt alpha, eta, CM

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CM
  !f2py intent(out) dalpha, dCM
  !f2py depend(numSeg) alpha, eta, CM, dalpha, dCM

  !Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CM
  double precision, dimension(0:numSeg-1), intent(out) :: dalpha, dCM

  integer :: i = 0

  do i = 0,numSeg-1
     dalpha(i) = 0.63/1.06
     dCM(i) = -1/1.06
  enddo

end subroutine getDEta

subroutine get_sfc(numElem, SFCSL, h, SFC)
  !f2py intent(in) numElem
  !f2py intent(in) SFCSL
  !f2py intent(in) h
  !f2py intent(out) SFC
  !f2py depend(numElem) h, SFC

  integer, intent(in) :: numElem
  double precision, intent(in) :: SFCSL
  double precision, dimension(0:numElem), intent(in) :: h
  double precision, dimension(0:numElem), intent(out) :: SFC

  SFC = SFCSL + (6.39e-13)*h

end subroutine get_sfc

subroutine get_sfc_d(numElem, dSFC)
  !f2py intent(in) numElem
  !f2py intent(out) dSFC
  !f2py depend(numElem) dSFC

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(out) :: dSFC

  integer :: i
  
  do i=0,numElem
     dSFC(i) = 6.39e-13
  enddo

end subroutine get_sfc_d

subroutine get_gamma(numElem, h, x, gamma)
  !f2py intent(in) numElem
  !f2py intent(in) h, x
  !f2py intent(out) gamma
  !f2py depend(numElem) h, x, gamma

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: h, x
  double precision, dimension(0:numElem), intent(out) :: gamma

  integer :: i
  double precision :: dx

  dx = x(1)-x(0)
  do i=0,1
     gamma(i) = -(3.0/2.0)*h(i) + 2.0*h(i+1) - (1.0/2.0)*h(i+2)
     gamma(i) = gamma(i) / dx
  enddo

  do i=2,numElem-2
     gamma(i) = (1.0/12.0)*h(i-2) - (2.0/3.0)*h(i-1) + (2.0/3.0)*h(i+1) - (1.0/12.0)*h(i+2)
     gamma(i) = gamma(i) / dx
  enddo

  do i=numElem-2,numElem
     gamma(i) = (1.0/2.0)*h(i-2) - 2.0*h(i-1) + (3.0/2.0)*h(i)
     gamma(i) = gamma(i) / dx
  enddo
end subroutine get_gamma

subroutine get_gamma_d(numElem, h, x, dhgamma1, dhgamma2, dhgamma3, dhgamma4, &
     dhgamma5, dxgamma0, dxgamma1)
  !f2py intent(in) numElem
  !f2py intent(in) h, x
  !f2py intent(out) dhgamma1, dhgamma2, dhgamma3, dhgamma4, dhgamma5, dxgamma
  !f2py depend(numElem) h, x, dhgamma1, dhgamma2, dhgamma3, dhgamma4, dhgamma5, dxgamma0, dxgamma1

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: h, x
  double precision, dimension(0:numElem), intent(out) :: dhgamma1, dhgamma2, &
       dhgamma3, dhgamma4, dhgamma5, dxgamma0, dxgamma1

  integer :: i
  double precision :: dx, dx0, dx1

  dx = x(1)-x(0)
  dx0 = -1/numElem
  dx1 = 1/numElem

  do i=0,1
     dhgamma1(i) = 0.0
     dhgamma2(i) = 0.0
     dhgamma3(i) = -3.0/2.0
     dhgamma4(i) = 2.0
     dhgamma5(i) = -1.0/2.0
     dxgamma0(i) = (3.0/2.0)*h(i) - 2.0*h(i+1) + (1.0/2.0)*h(i+2)
     dxgamma0(i) = dxgamma0(i) / dx**2
     dxgamma1(i) = dxgamma0(i) * dx1
     dxgamma0(i) = dxgamma0(i) * dx0
  enddo

  do i=2,numElem-2
     dhgamma1(i) = 1.0/12.0
     dhgamma2(i) = -2.0/3.0
     dhgamma3(i) = 0.0
     dhgamma4(i) = 2.0/3.0
     dhgamma5(i) = -1.0/12.0
     dxgamma0(i) = -(1.0/12.0)*h(i-2) + (2.0/3.0)*h(i-1) - (2.0/3.0)*h(i+1) + (1.0/12.0)*h(i+2)
     dxgamma0(i) = dxgamma0(i) / dx**2
     dxgamma1(i) = dxgamma0(i) * dx1
     dxgamma0(i) = dxgamma0(i) * dx0
  enddo

  do i=numElem-2,numElem
     dhgamma1(i) = 1.0/2.0
     dhgamma2(i) = -2.0
     dhgamma3(i) = 3.0/2.0
     dhgamma4(i) = 0.0
     dhgamma5(i) = 0.0
     dxgamma0(i) = -(1.0/2.0)*h(i-2) + 2.0*h(i-1) - (3.0/2.0)*h(i)
     dxgamma0(i) = dxgamma0(i) / dx**2
     dxgamma1(i) = dxgamma0(i) * dx1
     dxgamma0(i) = dxgamma0(i) * dx0
  enddo
end subroutine get_gamma_d

subroutine get_Temp(numElem, h, Temp)
  !f2py intent(in) numElem
  !f2py intent(in) h
  !f2py intent(out) Temp
  !f2py depend(numElem) h, Temp

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: h
  double precision, dimension(0:numElem), intent(out) :: Temp

  integer :: i

  Temp = 288.16 - (6.5e-3)*h

  do i=0,numElem
     if (Temp(i) < 1) then
        Temp(i) = 1.0
     endif
  enddo

end subroutine get_Temp

subroutine get_Temp_d(numElem, h, dTemp)
  !f2py intent(in) numElem
  !f2py intent(in) h
  !f2py intent(out) dTemp
  !f2py depend(numElem) h, dTemp

  integer, intent(in) :: numElem
  double precision, dimension(0:numElem), intent(in) :: h
  double precision, dimension(0:numElem), intent(out) :: dTemp

  integer :: i
  double precision, dimension(0:numElem) :: Temp

  Temp = 288.16 - (6.5e-3)*h

  do i=0,numElem
     dTemp(i) = -6.5e-3
     if (Temp(i) < 1) then
        dTemp(i) = 0.0
     endif
  enddo
end subroutine get_Temp_d

subroutine get_rho(numElem, g, Temp, rho)
  !f2py intent(in) numElem
  !f2py intent(in) g
  !f2py intent(in) Temp
  !f2py intent(out) rho
  !f2py depend(numElem) Temp, rho

  integer, intent(in) :: numElem
  double precision, intent(in) :: g
  double precision, dimension(0:numElem), intent(in) :: Temp
  double precision, dimension(0:numElem), intent(out) :: rho

  integer :: i

  rho = 1.225*(Temp/288.16)**(-((9.81/((-6.5e-3)*287))+1))

  do i=0,numElem
     if (rho(i) < 0.01) then
        rho(i) = 0.01
     endif
  enddo

end subroutine get_rho

subroutine get_rho_d(numElem, g, Temp, dRho)
  !f2py intent(in) numElem
  !f2py intent(in) g
  !f2py intent(in) Temp
  !f2py intent(out) dRho
  !f2py depend(numElem) Temp, dRho

  integer, intent(in) :: numElem
  double precision, intent(in) :: g
  double precision, dimension(0:numElem), intent(in) :: Temp
  double precision, dimension(0:numElem), intent(out) :: dRho
  
  integer :: i
  double precision, dimension(0:numElem) :: rho

  rho = 1.225*(Temp/288.16)**(-((9.81/((-6.5e-3)*287))+1))

  do i=0,numElem
     dRho(i) = 1.225*(Temp(i)/288.16)**(-((9.81/((-6.5e-3)*287))+2))
     dRho(i) = dRho(i) * (-9.81/((-6.5e-3)*287)-1)*(1/288.16)
     if (rho(i) < 0.01) then
        dRho(i) = 0.0
     endif
  enddo
end subroutine get_rho_d

subroutine get_v(numElem, v_ends, v)
  !f2py intent(in) numElem
  !f2py intent(in) v_ends
  !f2py intent(out) v
  !f2py depend(numElem) v

  integer, intent(in) :: numElem
  double precision, dimension(0:1), intent(in) :: v_ends
  double precision, dimension(0:numElem), intent(out) :: v

  integer :: i
  double precision :: dv

  dv = (v_ends(1)-v_ends(0))/numElem
  do i=0,numElem
     v(i) = dv*i+v_ends(0)
  enddo
end subroutine get_v

subroutine get_v_d(numElem, v_ends, dv0, dv1)
  !f2py intent(in) numElem
  !f2py intent(in) v_ends
  !f2py intent(out) dv
  !f2py depend(numElem) dv

  integer, intent(in) :: numElem
  double precision, dimension(0:1), intent(in) :: v_ends
  double precision, dimension(0:numElem), intent(out) :: dv0, dv1

  integer :: i

  do i=0,numElem
     dv0(i) = -real(i)/numElem + 1
     dv1(i) = real(i)/numElem
  enddo
end subroutine get_v_d

subroutine get_CT_Init(numElem, tau, S, cThrustSL, rho, v, h, CT)
  !f2py intent(in) numElem
  !f2py intent(in) tau, S, cThrustSL
  !f2py intent(in) rho, v, h
  !f2py intent(out) CT
  !f2py depend(numElem) rho, v, h, CT

  integer, intent(in) :: numElem
  double precision, intent(in) :: tau, S, cThrustSL
  double precision, dimension(0:numElem), intent(in) :: rho, v, h
  double precision, dimension(0:numElem), intent(out) :: CT

  integer :: i
  double precision, dimension(0:numElem) :: cThrust

  do i=0,numElem
     cThrust(i) = cThrustSL - 0.072*h(i)
     CT(i) = (2/(rho(i)*v(i)**2*S))*cThrust(i)*tau
  enddo
end subroutine get_CT_Init

subroutine get_CT_Init_d(numElem, tau, S, cThrustSL, rho, v, h, &
     dcThrustSL, dh, drho, dv, dS, dtau)
  !f2py intent(in) numElem
  !f2py intent(in) tau, S, cThrustSL
  !f2py intent(in) rho, v, h
  !f2py intent(out) dcThrustSL, dh, drho, dv, dS, dtau
  !f2py depend(numElem) rho, v, h, dcThrustSL, dh, drho, dv, dS, dtau

  integer, intent(in) :: numElem
  double precision, intent(in) :: tau, S, cThrustSL
  double precision, dimension(0:numElem), intent(in) :: rho, v, h
  double precision, dimension(0:numElem), intent(out) :: dcThrustSL, &
       dh, drho, dv, dS, dtau

  integer :: i
  double precision :: cThrust

  do i=0,numElem
     cThrust = cThrustSL - 0.072*h(i)
     dcThrustSL(i) = 2*tau/(rho(i)*v(i)**2*S)
     dh(i) = -0.144*tau/(rho(i)*v(i)**2*S)
     drho(i) = -2*cThrust*tau/(rho(i)**2*v(i)**2*S)
     dv(i) = -4*cThrust*tau/(rho(i)*v(i)**3*S)
     dS(i) = -2*cThrust*tau/(rho(i)*v(i)**2*S**2)
     dtau(i) = 2*cThrust/(rho(i)*v(i)**2*S)
  enddo
end subroutine get_CT_Init_d

subroutine get_h(numElem, numInt, S, Wac, x_ends, h_ends, Wf, CT, alpha, CD, rho, v, h)
  !f2py intent(in) numElem, numInt
  !f2py intent(in) S, Wac
  !f2py intent(in) x_ends, h_ends
  !f2py intent(in) Wf, CT, alpha, CD, rho, v
  !f2py intent(out) h
  !f2py depend(numElem) Wf, CT, alpha, CD, rho, v, h

  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: S, Wac
  double precision, dimension(0:1), intent(in) :: x_ends, h_ends
  double precision, dimension(0:numElem), intent(in) :: Wf, &
       CT, alpha, CD, rho, v
  double precision, dimension(0:numElem), intent(out) :: h

  integer :: i
  double precision :: dx, dh
  double precision, dimension(0:numElem) :: x
  double precision, dimension(0:numInt) :: xTemp, WfTemp, CTTemp, aTemp, &
       CDTemp, rhoTemp, vTemp

  dx = (x_ends(1)-x_ends(0))/numElem

  do i=0,numElem
     x(i) = i*dx+x_ends(0)
     h(i) = 0
  enddo

  h(0) = h_ends(0)
  do i=0,numElem-1
     h(i+1) = h(i)
     call linspace(numInt+1,x(i),x(i+1),xTemp)
     call linspace(numInt+1,Wf(i),Wf(i+1),WfTemp)
     call linspace(numInt+1,CT(i),CT(i+1),CTTemp)
     call linspace(numInt+1,alpha(i),alpha(i+1),aTemp)
     call linspace(numInt+1,CD(i),CD(i+1),CDTemp)
     call linspace(numInt+1,rho(i),rho(i+1),rhoTemp)
     call linspace(numInt+1,v(i),v(i+1),vTemp)

     do j=0,numInt-1
        dh = ((xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac))*(0.5*rhoTemp(j)*vTemp(j)**2*S)
        dh = dh*(CTTemp(j)*COS(aTemp(j))-CDTemp(j))
        h(i+1) = h(i+1)+dh
     enddo
  enddo
end subroutine get_h

subroutine get_h_d(numElem, numInt, S, Wac, x_ends, h_ends, Wf, CT, alpha, CD, rho, &
     v, dhdx0, dhdx1, dhdWf1, dhdWf2, dhdRho1, dhdRho2, dhdV1, dhdV2, dhdCT1, &
     dhdCT2, dhda1, dhda2, dhdCD1, dhdCD2)
  !f2py intent(in) numElem, numInt
  !f2py intent(in) S, Wac
  !f2py intent(in) x_ends, h_ends
  !f2py intent(in) Wf, CT, alpha, CD, rho, v
  !f2py intent(out) dhdx0, dhdx1, dhdWf1, dhdWf2, dhdRho1, dhdRho2, dhdV1, dhdV2, dhdCT1, dhdCT2, dhda1, dhda2, dhdCD1, dhdCD2
  !f2py depend(numElem) Wf, CT, alpha, CD, rho, v, dhdx0, dhdx1, dhdWf1, dhdWf2, dhdRho1, dhdRho2, dhdV1, dhdV2, dhdCT1, dhdCT2, dhda1, dhda1, dhdCD1, dhdCD2

  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: S, Wac
  double precision, dimension(0:1), intent(in) :: x_ends, h_ends
  double precision, dimension(0:numElem), intent(in) :: Wf, &
       CT, alpha, CD, rho, v
  double precision, dimension(0:numElem), intent(out) :: dhdx0, dhdx1, &
       dhdWf1, dhdWf2, dhdRho1, dhdRho2, dhdV1, dhdV2, dhdCT1, dhdCT2, &
       dhda1, dhda2, dhdCD1, dhdCD2

  double precision :: cosa, delta_x, temp
  double precision, dimension(0:numElem) :: delxTemp0, delxTemp1, x
  double precision, dimension(0:numInt) :: dxTemp0, dxTemp1, dWfTemp1, &
       dWfTemp2, dCTTemp1, dCTTemp2, daTemp1, daTemp2, dCDTemp1, dCDTemp2, &
       drhoTemp1, drhoTemp2, dvTemp1, dvTemp2, xTemp, WfTemp, CTTemp, aTemp, &
       CDTemp, rhoTemp, vTemp

  delta_x = (x_ends(1)-x_ends(0))/numElem

  do i=0,numElem
     x(i) = i*delta_x+x_ends(0)
     delxTemp0(i) = -i/numElem+1
     delxTemp1(i) = i/numElem
     dhdx0(i) = 0.0
     dhdx1(i) = 0.0
     dhdWf1(i) = 0.0
     dhdWf2(i) = 0.0
     dhdRho1(i) = 0.0
     dhdRho2(i) = 0.0
     dhdV1(i) = 0.0
     dhdV2(i) = 0.0
     dhdCT1(i) = 0.0
     dhdCT2(i) = 0.0
     dhda1(i) = 0.0
     dhda2(i) = 0.0
     dhdCD1(i) = 0.0
     dhdCD2(i) = 0.0
  enddo

  do i=0,numElem-1
     dhdx0(i+1) = dhdx0(i)
     dhdx1(i+1) = dhdx1(i)
     dhdWf1(i+1) = dhdWf1(i)
     dhdWf2(i+1) = dhdWf2(i)
     dhdRho1(i+1) = dhdRho1(i)
     dhdRho2(i+1) = dhdRho2(i)
     dhdV1(i+1) = dhdV1(i)
     dhdV2(i+1) = dhdV2(i)
     dhdCT1(i+1) = dhdCT1(i)
     dhdCT2(i+1) = dhdCT2(i)
     dhda1(i+1) = dhda1(i)
     dhda2(i+1) = dhda2(i)
     dhdCD1(i+1) = dhdCD1(i)
     dhdCD2(i+1) = dhdCD2(i)

     call dlinspace(numInt+1,x(i),x(i+1),dxTemp0,dxTemp1)
     call dlinspace(numInt+1,Wf(i),Wf(i+1),dWfTemp1,dWfTemp2)
     call dlinspace(numInt+1,CT(i),CT(i+1),dCTTemp1,dCTTemp2)
     call dlinspace(numInt+1,alpha(i),alpha(i+1),daTemp1,daTemp2)
     call dlinspace(numInt+1,CD(i),CD(i+1),dCDTemp1,dCDTemp2)
     call dlinspace(numInt+1,rho(i),rho(i+1),drhoTemp1,drhoTemp2)
     call dlinspace(numInt+1,v(i),v(i+1),dvTemp1,dvTemp2)

     call linspace(numInt+1,x(i),x(i+1),xTemp)
     call linspace(numInt+1,Wf(i),Wf(i+1),WfTemp)
     call linspace(numInt+1,CT(i),CT(i+1),CTTemp)
     call linspace(numInt+1,alpha(i),alpha(i+1),aTemp)
     call linspace(numInt+1,CD(i),CD(i+1),CDTemp)
     call linspace(numInt+1,rho(i),rho(i+1),rhoTemp)
     call linspace(numInt+1,v(i),v(i+1),vTemp)

     do j=0,numInt-1
        cosa = COS(aTemp(j))
        
        temp = dxTemp1(j+1)*delxTemp0(i+1)+dxTemp0(j+1)*delxTemp0(i)
        temp = temp - dxTemp1(j)*delxTemp0(i+1)-dxTemp0(j)*delxTemp0(i)
        temp = temp / (WfTemp(j)+Wac) * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdx0(i+1) = dhdx0(i+1) + temp

        temp = dxTemp1(j+1)*delxTemp1(i+1)+dxTemp0(j+1)*delxTemp1(i)
        temp = temp - dxTemp1(j)*delxTemp1(i+1)-dxTemp0(j)*delxTemp1(i)
        temp = temp / (WfTemp(j)+Wac) * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdx1(i+1) = dhdx1(i+1) + temp

        temp = -(xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)**2
        temp = temp * dWfTemp1(j)*(0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdWf1(i+1) = dhdWf1(i+1) + temp
        
        temp = -(xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)**2
        temp = temp * dWfTemp2(j)*(0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdWf2(i+1) = dhdWf2(i+1) + temp
        
        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*vTemp(j)**2*S)*drhoTemp1(j)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdRho1(i+1) = dhdRho1(i+1) + temp
        
        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*vTemp(j)**2*S)*drhoTemp2(j)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdRho2(i+1) = dhdRho2(i+1) + temp

        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (rhoTemp(j)*vTemp(j)*dvTemp1(j)*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdV1(i+1) = dhdV1(i+1) + temp
        
        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (rhoTemp(j)*vTemp(j)*dvTemp2(j)*S)
        temp = temp * (CTTemp(j)*cosa - CDTemp(j))
        dhdV2(i+1) = dhdV2(i+1) + temp

        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (dCTTemp1(j)*cosa - CDTemp(j))
        dhdCT1(i+1) = dhdCT1(i+1) + temp
        
        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (dCTTemp2(j)*cosa - CDTemp(j))
        dhdCT2(i+1) = dhdCT2(i+1) + temp

        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (-CTTemp(j)*SIN(aTemp(j))*daTemp1(j))
        dhda1(i+1) = dhda1(i+1) + temp

        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (-CTTemp(j)*SIN(aTemp(j))*daTemp2(j))
        dhda2(i+1) = dhda2(i+1) + temp

        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (-dCDTemp1(j))
        dhdCD1(i+1) = dhdCD1(i+1) + temp
        
        temp = (xTemp(j+1)-xTemp(j))/(WfTemp(j)+Wac)
        temp = temp * (0.5*rhoTemp(j)*vTemp(j)**2*S)
        temp = temp * (-dCDTemp2(j))
        dhdCD2(i+1) = dhdCD2(i+1) + temp
     enddo
  enddo
end subroutine get_h_d

subroutine linspace(n, x0, x1, y)
  ! fortran implementation of linspace function

  !Input/Output
  integer, intent(in) :: n
  double precision, intent(in) :: x0, x1
  double precision, dimension(0:n-1), intent(out) :: y

  double precision :: dx
  integer :: i

  dx = (x1-x0)/(n-1)

  do i = 0,n-1
     y(i) = x0 + dx*i
  enddo

end subroutine linspace

subroutine dlinspace(n, x0, x1, dy1, dy2)
  ! computes the derivatives of the output of linspace function
  ! wrt to the two inputs x0, and x1

  !Input/Output
  integer, intent(in) :: n
  double precision, intent(in) :: x0, x1
  double precision, dimension(0:n-1), intent(out) :: dy1, dy2

  integer :: i

  do i = 0,n-1
     dy1(i) = (1-real(i)/real(n-1))
     dy2(i) = real(i)/real(n-1)
  enddo

end subroutine dlinspace

subroutine get_tau(numElem, cThrustSL, S, CT, rho, v, h, tau)
  !f2py intent(in) numElem
  !f2py intent(in) cThrustSL, S
  !f2py intent(in) CT, rho, v, h
  !f2py intent(out) tau
  !f2py depend(numElem) CT, rho, v, h, tau

  integer, intent(in) :: numElem
  double precision, intent(in) :: cThrustSL, S
  double precision, dimension(0:numElem), intent(in) :: CT, rho, v, h
  double precision, dimension(0:numElem), intent(out) :: tau

  integer :: i = 0
  double precision, dimension(0:numElem) :: cThrust, Thrust

  do i = 0,numElem
     cThrust(i) = cThrustSL - 0.072*h(i)
     Thrust(i) = 0.5*rho(i)*v(i)**2*S*CT(i)
     tau(i) = Thrust(i)/cThrust(i)
  enddo

end subroutine get_tau

subroutine get_tau_d(numElem, cThrustSL, S, h, CT, rho, v, dCThrustSL, dh, dCT, &
     dRho, dV, dS)
  ! computes the derivatives of throttle setting wrt
  ! propulsion parameters, h, tau, and thrust

  !f2py intent(in) numElem
  !f2py intent(in) cThrustSL, S
  !f2py intent(in) h, CT, rho, v
  !f2py intent(out) dCThrustSL, dh, dCT, dRho, dV, dS
  !f2py depend(numElem) h, CT, rho, v, dCThrustSL, dh, dCT, dRho, dV, dS

  integer, intent(in) :: numElem
  double precision, intent(in) :: cThrustSL, S
  double precision, dimension(0:numElem), intent(in) :: h, CT, rho, v
  double precision, dimension(0:numElem), intent(out) :: dCThrustSL, dh, dCT, dRho, dV, dS

  integer :: i = 0
  double precision, dimension(0:numElem) :: cThrust

  do i = 0,numElem
     dRho(i) = (0.5*v(i)**2*S*CT(i))/(cThrustSL-0.072*h(i))
     dV(i) = (rho(i)*v(i)*S*CT(i))/(cThrustSL-0.072*h(i))
     dS(i) = (0.5*rho(i)*v(i)**2*CT(i))/(cThrustSL-0.072*h(i))
     dCT(i) = (0.5*rho(i)*v(i)**2*S)/(cThrustSL-0.072*h(i))
     dCThrustSL(i) = -(0.5*rho(i)*v(i)**2*S*CT(i))/(cThrustSL-0.072*h(i))**2
     dh(i) = -0.072*(0.5*rho(i)*v(i)**2*S*CT(i))/(cThrustSL-0.072*h(i))**2
  enddo

end subroutine get_tau_d

subroutine get_Wf(numInt, numElem, x, v, gamma, CT, SFC, rho, WfIn, g, WfSeg, Wf)
  ! computes fuel weight for each segment
  ! using a forward Euler scheme implemented backwards from the
  ! end of the mission
  ! the current initial condition is set to be 0 fuel at the end
  ! of the mission

  !f2py intent(in) numInt, numElem
  !f2py intent(in) x, v, gamma, CT, SFC, rho, WfIn
  !f2py intent(in) g, WfSeg
  !f2py intent(out) Wf
  !f2py depend(numElem) x, v, gamma, CT, SFC, rho, WfIn, Wf

  !Input/Output
  integer, intent(in) :: numInt, numElem
  double precision, dimension(0:numElem), intent(in) :: x, v, gamma
  double precision, dimension(0:numElem), intent(in) :: CT, SFC, rho, WfIn
  double precision, intent(in) :: g, WfSeg
!  double precision, intent(in) :: Wff
  double precision, dimension(0:numElem), intent(out) :: Wf

  double precision, dimension(0:numInt-1) :: vTemp, xTemp, SFCTemp, gammaTemp, cosGamma, rhoTemp, QTemp, CTTemp
  double precision :: dx, WfTemp
  integer :: i = 0, j = 0, k = 0, l = 0

  do i = 0,numElem
     Wf(i) = WfSeg
  enddo

  do i = 0,numElem-1

     j = numElem-1-i
     call linspace(numInt, v(j), v(j+1), vTemp)
     dx = (x(j+1)-x(j))/real(numInt)

     do k = 0,numInt-1
        xTemp(k) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx
     call linspace(numInt, SFC(j), SFC(j+1), SFCTemp)
     call linspace(numInt, gamma(j), gamma(j+1), gammaTemp)
     call linspace(numInt, CT(j), CT(j+1), CTTemp)
     call linspace(numInt, rho(j), rho(j+1), rhoTemp)
     QTemp = 0.5*rhoTemp*vTemp**2
     cosGamma = cos(gammaTemp)

     do k = 0,numInt-1
        WfTemp = SFCTemp(k)*CTTemp(k)*QTemp(k)
        WfTemp = WfTemp*xTemp(k)/(vTemp(k)*cosGamma(k))
        Wf(j) = Wf(j) + WfTemp*9.81
     enddo
  enddo

  do i = 0,numElem-1
     j = numElem-1-i
     Wf(j) = Wf(j) + Wf(j+1)
  enddo

end subroutine get_Wf

subroutine getDWf(numSeg, numInt, g, x, v, gamma, Thrust, cT, R1, R2, &
     dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2)
  ! computes the derivatives of fuel weights wrt
  ! propulsion parameters, thrust, v, gamma, and fuel weight
  ! the resultant jacobian is bi-diagonal, and is stored in 2
  ! vectors for each derivative, ie, d___1 and d___2

  !f2py intent(in) numSeg, numInt
  !f2py intent(in) g
  !f2py intent(in) x, v, gamma, Thrust, cT
  !f2py intent(in) R1, R2
  !f2py intent(out) dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2
  !f2py depend(numSeg) x, v, gamma, Thrust, cT, dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2
  !f2py depend(numInt) R1, R2

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, gamma
  double precision, dimension(0:numSeg-1), intent(in) :: Thrust, cT
  double precision, dimension(0:numInt-1), intent(in) :: R1, R2
  double precision, dimension(0:numSeg-1), intent(out) :: dCT1, dCT2, dThrust1, dThrust2
  double precision, dimension(0:numSeg-1), intent(out) :: dV1, dV2, dGamma1, dGamma2

  integer :: i = 0, j = 0, k = 0
  double precision :: deltax
  double precision :: dWfTempdCT1, dWfTempdCT2, dWfTempdThrust1, dWfTempdThrust2
  double precision :: dWfTempdV1, dWfTempdV2
  double precision :: dWfTempdGamma1, dWfTempdGamma2
  double precision, dimension(0:numInt-1) :: vTemp, xTemp, cTTemp, gammaTemp, cosGamma
  double precision, dimension(0:numInt-1) :: dVTemp1, dVTemp2, dCTTemp1, dCTTemp2, dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2

  do i = 0,numSeg-1
     dCT1(i) = 0.0
     dCT2(i) = 0.0
     dThrust1(i) = 0.0
     dThrust2(i) = 0.0
     dV1(i) = 0.0
     dV2(i) = 0.0
     dGamma1(i) = 0.0
     dGamma2(i) = 0.0
  enddo

  do i = 0,numSeg-2

     j = numSeg-2-i
     call linspace(numInt, v(j), v(j+1), vTemp)
     call dlinspace(numInt, v(j), v(j+1), dVTemp1, dVTemp2)
     deltax = (x(j+1)-x(j))/real(numInt)

     do k = 0,numInt-1
        xTemp(k) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, cT(j), cT(j+1), cTTemp)
     call dlinspace(numInt, cT(j), cT(j+1), dCTTemp1, dCTTemp2)
     call linspace(numInt, gamma(j), gamma(j+1), gammaTemp)
     call dlinspace(numInt, gamma(j), gamma(j+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2

     do k = 0,numInt-1

        dWfTempdCT1 = (Thrust(j+1)*R1(k)+Thrust(j)*R2(k))*xTemp(k)/(vTemp(k)*cosGamma(k))
        dWfTempdCT2 = dWfTempdCT1
        dWfTempdCT1 = dWfTempdCT1*dCTTemp1(k)
        dWfTempdCT2 = dWfTempdCT2*dCTTemp2(k)
        dCT1(j) = dCT1(j)+dWfTempdCT1*g
        dCT2(j+1) = dCT2(j+1)+dWfTempdCT2*g
        
        dWfTempdThrust1 = cTTemp(k)*R2(k)*xTemp(k)/(vTemp(k)*cosGamma(k))
        dWfTempdThrust2 = cTTemp(k)*R1(k)*xTemp(k)/(vTemp(k)*cosGamma(k))
        dThrust1(j) = dThrust1(j)+dWfTempdThrust1*g
        dThrust2(j+1) = dThrust2(j+1)+dWfTempdThrust2*g

        dWfTempdV1 = -(cTTemp(k)*Thrust(j+1)*R1(k)+cTTemp(k)*Thrust(j)*R2(k))/(cosGamma(k)*vTemp(k)**2)*xTemp(k)
        dWfTempdV2 = dWfTempdV1
        dWfTempdV1 = dWfTempdV1*dVTemp1(k)
        dWfTempdV2 = dWfTempdV2*dVTemp2(k)
        dV1(j) = dV1(j)+dWfTempdV1*g
        dV2(j+1) = dV2(j+1)+dWfTempdV2*g

        dWfTempdGamma1 = -(cTTemp(k)*Thrust(j+1)*R1(k)+cTTemp(k)*Thrust(j)*R2(k))/(vTemp(k)*cosGamma(k)**2)*xTemp(k)
        dWfTempdGamma2 = dWfTempdGamma1
        dWfTempdGamma1 = dWfTempdGamma1*dCosGamma1(k)
        dWfTempdGamma2 = dWfTempdGamma2*dCosGamma2(k)
        dGamma1(j) = dGamma1(j)+dWfTempdGamma1*g
        dGamma2(j+1) = dGamma2(j+1)+dWfTempdGamma2*g
     enddo
  enddo
       
end subroutine getDWf

  ! compute the residuals for CL using the governing flight equation
  ! the flight equation is integrated, and the resultant value is 
  ! determined to be the residual for alpha
  
subroutine get_CL(numElem, numInt, Wac, S, g, x, v, rho, CL, Wf, gamma, &
     CT, alpha, CLRes)

  !f2py intent(in) numElem, numInt
  !f2py intent(in) Wac, S, g
  !f2py intent(in) x, v, rho, CL, Wf, gamma, CT, alpha
  !f2py intent(out) CLRes
  !f2py depend(numElem) x, v, rho, CL, Wf, gamma, CT, alpha

  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: Wac, S, g
  double precision, dimension(0:numElem), intent(in) :: x, v, rho, CL, Wf, gamma, CT, alpha
  double precision, dimension(0:numElem), intent(out) :: CLRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma
  double precision, dimension(0:numInt-1) :: CLTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numElem,0:numInt-1) :: alphaTemp

  do i = 0,numElem
     do j = 0,numInt-1
        alphaTemp(i,j) = 0.0
     enddo
     CLRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)     
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = CT(i)*R1(j) + CT(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        temp = temp-sin(aTemp(j))*tTemp(j)*QTemp(j)
        temp = temp*R1(j)*xTemp(j)
        alphaTemp(i,j) = alphaTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)

     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = CT(i)*R1(j) + CT(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        temp = temp-sin(aTemp(j))*tTemp(j)*QTemp(j)
        temp = temp*R2(j)*xTemp(j)
        alphaTemp(i+1,j) = alphaTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numElem
     do j = 0,numInt-1
        CLRes(i) = CLRes(i) + alphaTemp(i,j)
     enddo
  enddo

end subroutine get_CL

subroutine get_CL_d(numElem, numInt, Wac, S, g, x, v, rho, CL, Wf, gamma, &
     Thrust, alpha, dGamma, dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, &
     dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, &
     dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3)
  ! compute the derivatives of the residuals of CL wrt gamma,
  ! empty weight, S, v, rho, CL, fuel weight, gamma, thrust,
  ! alpha, dgamma/dx
  ! the jacobian structure is tri-diagonal, and is stored in 3
  ! vectors for each derivative

  !f2py intent(in) numElem, numInt
  !f2py intent(in) Wac, S, g
  !f2py intent(in) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  !f2py intent(out) dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, dCLdCL1, dCLdCL2, dCLdCL3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3
  !f2py depend(numElem) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma, dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3

  ! Input/Output
  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: Wac, S, g
  double precision, dimension(0:numElem), intent(in) :: x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  double precision, dimension(0:numElem), intent(out) :: dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3
  double precision, dimension(0:numElem), intent(out) :: dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1
  double precision, dimension(0:numElem), intent(out) :: dCLdGamma2, dCLdGamma3
  double precision, dimension(0:numElem), intent(out) :: dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3
  double precision, dimension(0:numElem), intent(out) :: dCLddGamma1, dCLddGamma2, dCLddGamma3

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: CLTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numInt-1) :: dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2
  double precision, dimension(0:numInt-1) :: dQTempdS
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2
  double precision, dimension(0:numInt-1) :: dVTemp1, dVTemp2
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: ddGammaTemp1, ddGammaTemp2
  double precision, dimension(0:numInt-1) :: dCLTemp1, dCLTemp2
  double precision, dimension(0:numInt-1) :: dWTempdWf1, dWTempdWf2
  double precision, dimension(0:numInt-1) :: dWTempdWac, dATemp1, dATemp2
  double precision, dimension(0:numInt-1) :: dTTemp1, dTTemp2

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numElem
     dCLdWac(i) = 0.0
     dCLdS(i) = 0.0
     dCLdV1(i) = 0.0
     dCLdV2(i) = 0.0
     dCLdV3(i) = 0.0
     dCLdRho1(i) = 0.0
     dCLdRho2(i) = 0.0
     dCLdRho3(i) = 0.0
     dCLdCL1(i) = 0.0
     dCLdCL2(i) = 0.0
     dCLdCL3(i) = 0.0
     dCLdWf1(i) = 0.0
     dCLdWf2(i) = 0.0
     dCLdWf3(i) = 0.0
     dCLdGamma1(i) = 0.0
     dCLdGamma2(i) = 0.0
     dCLdGamma3(i) = 0.0
     dCLdThrust1(i) = 0.0
     dCLdThrust2(i) = 0.0
     dCLdThrust3(i) = 0.0
     dCLdAlpha1(i) = 0.0
     dCLdAlpha2(i) = 0.0
     dCLdAlpha3(i) = 0.0
     dCLddGamma1(i) = 0.0
     dCLddGamma2(i) = 0.0
     dCLddGamma3(i) = 0.0
  enddo

  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        dQTempdRho1(j) = 0.5*vTemp(j)**2*S*dRhoTemp1(j)
        dQTempdRho2(j) = 0.5*vTemp(j)**2*S*dRhoTemp2(j)
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        dCLTemp1(j) = R1(j)
        dCLTemp2(j) = R2(j)
        
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0

        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)

        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCLdWac(i) = dCLdWac(i)+R1(j)*xTemp(j)*(cosGamma(j)*dWTempdWac(j) &
             +(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j)*dWTempdWac(j))
        dCLdS(i) = dCLdS(i)-R1(j)*xTemp(j)*(dQTempdS(j)*CLTemp(j))
        dCLdV2(i) = dCLdV2(i)+R1(j)*xTemp(j)*(-dQTempdV1(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp1(j)*cosGamma(j)*dGammaTemp(j))
        dCLdV3(i) = dCLdV3(i)+R1(j)*xTemp(j)*(-dQTempdV2(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp2(j)*cosGamma(j)*dGammaTemp(j))
        dCLdRho2(i) = dCLdRho2(i)+R1(j)*xTemp(j)*(-dQTempdRho1(j)*CLTemp(j))
        dCLdRho3(i) = dCLdRho3(i)+R1(j)*xTemp(j)*(-dQTempdRho2(j)*CLTemp(j))
        dCLdCL2(i) = dCLdCL2(i)+R1(j)*xTemp(j)*(-QTemp(j)*dCLTemp1(j))
        dCLdCL3(i) = dCLdCL3(i)+R1(j)*xTemp(j)*(-QTemp(j)*dCLTemp2(j))
        dCLdWf2(i) = dCLdWf2(i)+R1(j)*xTemp(j)*(dWTempdWf1(j)*cosGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdWf3(i) = dCLdWf3(i)+R1(j)*xTemp(j)*(dWTempdWf2(j)*cosGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdGamma2(i) = dCLdGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*dCosGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma1(j)*dGammaTemp(j))
        dCLdGamma3(i) = dCLdGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*dCosGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma2(j)*dGammaTemp(j))
        dCLdThrust2(i) = dCLdThrust2(i)+R1(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp1(j))
        dCLdThrust3(i) = dCLdThrust3(i)+R1(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp2(j))
        dCLdAlpha2(i) = dCLdAlpha2(i)+R1(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp1(j))
        dCLdAlpha3(i) = dCLdAlpha3(i)+R1(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp2(j))
        dCLddGamma2(i) = dCLddGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp1(j))
        dCLddGamma3(i) = dCLddGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp2(j))
     enddo
  enddo

  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp1, dGammaTemp2)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        dCLTemp1(j) = R1(j)
        dCLTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCLdWac(i+1) = dCLdWac(i+1)+R2(j)*xTemp(j)*(cosGamma(j)*dWTempdWac(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdS(i+1) = dCLdS(i+1)+R2(j)*xTemp(j)*(-dQTempdS(j)*CLTemp(j))
        dCLdV1(i+1) = dCLdV1(i+1)+R2(j)*xTemp(j)*(-dQTempdV1(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp1(j)*cosGamma(j)*dGammaTemp(j))
        dCLdV2(i+1) = dCLdV2(i+1)+R2(j)*xTemp(j)*(-dQTempdV2(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp2(j)*cosGamma(j)*dGammaTemp(j))
        dCLdRho1(i+1) = dCLdRho1(i+1)+R2(j)*xTemp(j)*(-dQTempdRho1(j)*CLTemp(j))
        dCLdRho2(i+1) = dCLdRho2(i+1)+R2(j)*xTemp(j)*(-dQTempdRho2(j)*CLTemp(j))
        dCLdCL1(i+1) = dCLdCL1(i+1)+R2(j)*xTemp(j)*(-QTemp(j)*dCLTemp1(j))
        dCLdCL2(i+1) = dCLdCL2(i+1)+R2(j)*xTemp(j)*(-QTemp(j)*dCLTemp2(j))
        dCLdWf1(i+1) = dCLdWf1(i+1)+R2(j)*xTemp(j)*(dWTempdWf1(j)*cosGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdWf2(i+1) = dCLdWf2(i+1)+R2(j)*xTemp(j)*(dWTempdWf2(j)*cosGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdGamma1(i+1) = dCLdGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dCosGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma1(j)*dGammaTemp(j))
        dCLdGamma2(i+1) = dCLdGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dCosGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma2(j)*dGammaTemp(j))
        dCLdThrust1(i+1) = dCLdThrust1(i+1)+R2(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp1(j))
        dCLdThrust2(i+1) = dCLdThrust2(i+1)+R2(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp2(j))
        dCLdAlpha1(i+1) = dCLdAlpha1(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp1(j))
        dCLdAlpha2(i+1) = dCLdAlpha2(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp2(j))
        dCLddGamma1(i+1) = dCLddGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp1(j))
        dCLddGamma2(i+1) = dCLddGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp2(j))
     enddo
  enddo

end subroutine getDCL

subroutine getThrustRes(numSeg, numInt, S, Wac, g, x, v, rho, gamma, dv, CD, Wf, &
     alpha, Thrust, ThrustRes)
  ! compute the residuals for thrust by integrating the T = D flight equation
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, Wac, g
  !f2py intent(in) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust
  !f2py intent(out) ThrustRes
  !f2py depend(numSeg) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust, ThrustRes

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, Wac, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dv
  double precision, dimension(0:numSeg-1), intent(in) :: CD, Wf, alpha, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: ThrustRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp, dvTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, sinGamma
  double precision, dimension(0:numInt-1) :: CDTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numSeg-1,0:numInt-1) :: tauTemp

  do i = 0,numSeg-1
     do j = 0,numInt-1
        tauTemp(i,j) = 0.0
     enddo
     ThrustRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-cos(aTemp(j))*tTemp(j))
        temp = temp+QTemp(j)*CDTemp(j)
        temp = temp+WTemp(j)*sinGamma(j)
        temp = temp+WTemp(j)*(1/g)*vTemp(j)*cosgamma(j)*dvTemp(j)
        temp = temp*R1(j)*xTemp(j)
        tauTemp(i,j) = tauTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-cos(aTemp(j))*tTemp(j)+QTemp(j)*CDTemp(j))
        temp = temp+WTemp(j)*sinGamma(j)+WTemp(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j)
        temp = temp*R2(j)*xTemp(j)
        tauTemp(i+1,j) = tauTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numSeg-1
     do j = 0,numInt-1
        ThrustRes(i) = ThrustRes(i) + tauTemp(i,j)
     enddo
  enddo

end subroutine getThrustRes

subroutine getDThrust(numSeg, numInt, S, Wac, g, x, v, rho, gamma, dv, CD, Wf, &
     alpha, Thrust, dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, &
     dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, &
     dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3)
  ! compute the derivatives of residuals of thrust wrt S, empty weight,
  ! v, rho, gamma, dv/dx, CD, fuel weight, alpha, and thrust
  ! the jacobians are tri-diagonal, and are stored in 3 vectors
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, Wac, g
  !f2py intent(in) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust
  !f2py intent(out) dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3
  !f2py depend(numSeg) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust, dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3

  ! Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, Wac, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dv
  double precision, dimension(0:numSeg-1), intent(in) :: CD, Wf, alpha, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: dTdS, dTdWac, dTdV1
  double precision, dimension(0:numSeg-1), intent(out) :: dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdGamma1, dTdGamma2, dTdGamma3
  double precision, dimension(0:numSeg-1), intent(out) :: dTddV1, dTddV2, dTddV3, dTdCD1
  double precision, dimension(0:numSeg-1), intent(out) :: dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdAlpha1, dTdAlpha2, dTdAlpha3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdThrust1, dTdThrust2, dTdThrust3

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp, dvTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, sinGamma
  double precision, dimension(0:numInt-1) :: CDTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2, dVTemp1
  double precision, dimension(0:numInt-1) :: dVTemp2, dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2, dQTempdS
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: dSinGamma1, dSinGamma2
  double precision, dimension(0:numInt-1) :: ddVTemp1, ddVTemp2
  double precision, dimension(0:numInt-1) :: dCDTemp1, dCDTemp2
  double precision, dimension(0:numInt-1) :: dWTempdWf1, dWTempdWf2, dWTempdWac
  double precision, dimension(0:numInt-1) :: dATemp1, dATemp2, dTTemp1, dTTemp2
  
  do i = 0, numSeg-1
     dTdS(i) = 0.0
     dTdWac(i) = 0.0
     dTdV1(i) = 0.0
     dTdV2(i) = 0.0
     dTdV3(i) = 0.0
     dTdRho1(i) = 0.0
     dTdRho2(i) = 0.0
     dTdRho3(i) = 0.0
     dTdGamma1(i) = 0.0
     dTdGamma2(i) = 0.0
     dTdGamma3(i) = 0.0
     dTddV1(i) = 0.0
     dTddV2(i) = 0.0
     dTddV3(i) = 0.0
     dTdCD1(i) = 0.0
     dTdCD2(i) = 0.0
     dTdCD3(i) = 0.0
     dTdWf1(i) = 0.0
     dTdWf2(i) = 0.0
     dTdWf3(i) = 0.0
     dTdAlpha1(i) = 0.0
     dTdAlpha2(i) = 0.0
     dTdAlpha3(i) = 0.0
     dTdThrust1(i) = 0.0
     dTdThrust2(i) = 0.0
     dTdThrust3(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*vTemp(j)**2*dRhoTemp1(j)*S
        dQTempdRho2(j) = 0.5*vTemp(j)**2*dRhoTemp2(j)*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax
     
     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     dSinGamma1 = cos(gammaTemp)*dGammaTemp1
     dSinGamma2 = cos(gammaTemp)*dGammaTemp2
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)
     
     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        dCDTemp1(j) = R1(j)
        dCDTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dTdS(i) = dTdS(i)+R1(j)*xTemp(j)*(dQTempdS(j)*CDTemp(j))
        dTdWac(i) = dTdWac(i)+R1(j)*xTemp(j)*(dWTempdWac(j)*sinGamma(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdV2(i) = dTdV2(i)+R1(j)*xTemp(j)*(dQTempdV1(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dVTemp1(j))
        dTdV3(i) = dTdV3(i)+R1(j)*xTemp(j)*(dQTempdV2(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dvTemp2(j))
        dTdRho2(i) = dTdRho2(i)+R1(j)*xTemp(j)*(dQTempdRho1(j)*CDTemp(j))
        dTdRho3(i) = dTdRho3(i)+R1(j)*xTemp(j)*(dQTempdRho2(j)*CDTemp(j))
        dTdGamma2(i) = dTdGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*dSinGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma1(j)*dvTemp(j))
        dTdGamma3(i) = dTdGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*dSinGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma2(j)*dvTemp(j))
        dTddV2(i) = dTddV2(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp1(j))
        dTddV3(i) = dTddV3(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp2(j))
        dTdCD2(i) = dTdCD2(i)+R1(j)*xTemp(j)*(QTemp(j)*dCDTemp1(j))
        dTdCD3(i) = dTdCD3(i)+R1(j)*xTemp(j)*(QTemp(j)*dCDTemp2(j))
        dTdWf2(i) = dTdWf2(i)+R1(j)*xTemp(j)*(dWTempdWf1(j)*sinGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdWf3(i) = dTdWf3(i)+R1(j)*xTemp(j)*(dWTempdWf2(j)*sinGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdAlpha2(i) = dTdAlpha2(i)+R1(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp1(j))
        dTdAlpha3(i) = dTdAlpha3(i)+R1(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp2(j))
        dTdThrust2(i) = dTdThrust2(i)+R1(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp1(j))
        dTdThrust3(i) = dTdThrust3(i)+R1(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp2(j))
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     dSinGamma1 = cos(gammaTemp)*dGammaTemp1
     dSinGamma2 = cos(gammaTemp)*dGammaTemp2
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        dCDTemp1(j) = R1(j)
        dCDTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dTdS(i+1) = dTdS(i+1)+R2(j)*xTemp(j)*(dQTempdS(j)*CDTemp(j))
        dTdWac(i+1) = dTdWac(i+1)+R2(j)*xTemp(j)*(dWTempdWac(j)*sinGamma(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdV1(i+1) = dTdV1(i+1)+R2(j)*xTemp(j)*(dQTempdV1(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dVTemp1(j))
        dTdV2(i+1) = dTdV2(i+1)+R2(j)*xTemp(j)*(dQTempdV2(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dvTemp2(j))
        dTdRho1(i+1) = dTdRho1(i+1)+R2(j)*xTemp(j)*(dQTempdRho1(j)*CDTemp(j))
        dTdRho2(i+1) = dTdRho2(i+1)+R2(j)*xTemp(j)*(dQTempdRho2(j)*CDTemp(j))
        dTdGamma1(i+1) = dTdGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dSinGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma1(j)*dvTemp(j))
        dTdGamma2(i+1) = dTdGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dSinGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma2(j)*dvTemp(j))
        dTddV1(i+1) = dTddV1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp1(j))
        dTddV2(i+1) = dTddV2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp2(j))
        dTdCD1(i+1) = dTdCD1(i+1)+R2(j)*xTemp(j)*(QTemp(j)*dCDTemp1(j))
        dTdCD2(i+1) = dTdCD2(i+1)+R2(j)*xTemp(j)*(QTemp(j)*dCDTemp2(j))
        dTdWf1(i+1) = dTdWf1(i+1)+R2(j)*xTemp(j)*(dWTempdWf1(j)*sinGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdWf2(i+1) = dTdWf2(i+1)+R2(j)*xTemp(j)*(dWTempdWf2(j)*sinGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdAlpha1(i+1) = dTdAlpha1(i+1)+R2(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp1(j))
        dTdAlpha2(i+1) = dTdAlpha2(i+1)+R2(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp2(j))
        dTdThrust1(i+1) = dTdThrust1(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp1(j))
        dTdThrust2(i+1) = dTdThrust2(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp2(j))
     enddo
  enddo
end subroutine getDThrust

subroutine get_CM(numElem, numInt, S, chord, x, v, rho, CM, CMRes)
  ! compute the residuals of CM by integrating the moment flight equation

  !f2py intent(in) numElem, numInt
  !f2py intent(in) S, chord
  !f2py intent(in) x, v, rho, CM
  !f2py intent(out) CMRes
  !f2py depend(numElem) x, v, rho, CM, CMRes

  !Input/Output
  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: S, chord
  double precision, dimension(0:numElem), intent(in) :: x, v, rho
  double precision, dimension(0:numElem), intent(in) :: CM
  double precision, dimension(0:numElem), intent(out) :: CMRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: CMTemp
  double precision, dimension(0:numElem,0:numInt-1) :: etaTemp

  do i = 0,numElem
     do j = 0,numInt-1
        etaTemp(i,j) = 0.0
     enddo
     CMRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)
  
  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = QTemp(j)*chord*CMTemp(j)
        temp = temp*R1(j)*xTemp(j)
        etaTemp(i,j) = etaTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numElem-1
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx
     
     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = QTemp(j)*chord*CMTemp(j)
        temp = temp*R2(j)*xTemp(j)
        etaTemp(i+1,j) = etaTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numElem
     do j = 0,numInt-1
        CMRes(i) = CMRes(i) + etaTemp(i,j)
     enddo
  enddo

end subroutine get_CM

subroutine getDCM(numSeg, numInt, S, chord, inertia, x, v, rho, gamma, &
     dGamma, d2Gamma, dv, CM, dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, &
     dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, &
     dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3)
  ! compute the derivatives of residuals of CM wrt S, chord,
  ! inertia, v, rho, gamma, dgamma/dx, d2gamma/dx2, dv/dx, CM
  ! the jacobians are tri-diagonal, and are stored in 3 vectors
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, chord, inertia
  !f2py intent(in) x, v, rho, gamma, dGamma, d2Gamma, dv, CM
  !f2py intent(out) dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3
  !f2py depend(numSeg) x, v, rho, gamma, dGamma, d2Gamma, dv, CM, dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, chord, inertia
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dGamma
  double precision, dimension(0:numSeg-1), intent(in) :: d2Gamma, dv, CM
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdS, dCMdC, dCMdI
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdV1, dCMdV2, dCMdV3, dCMdRho1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdRho2, dCMdRho3, dCMdGamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdGamma2, dCMdGamma3, dCMddGamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMddGamma2, dCMddGamma3, dCMdd2Gamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3

  integer :: i = 0, j = 0, k = 0
  double precision :: deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: d2GammaTemp, dvTemp, CMTemp
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2, dVTemp1
  double precision, dimension(0:numInt-1) :: dVTemp2, dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2, dQTempdS
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: ddGammaTemp1, ddGammaTemp2
  double precision, dimension(0:numInt-1) :: dd2GammaTemp1, dd2GammaTemp2
  double precision, dimension(0:numInt-1) :: ddVTemp1, ddVTemp2, dCMTemp1, dCMTemp2
  
  do i = 0,numSeg-1
     dCMdS(i) = 0.0
     dCMdC(i) = 0.0
     dCMdI(i) = 0.0
     dCMdV1(i) = 0.0
     dCMdV2(i) = 0.0
     dCMdV3(i) = 0.0
     dCMdRho1(i) = 0.0
     dCMdRho2(i) = 0.0
     dCMdRho3(i) = 0.0
     dCMdGamma1(i) = 0.0
     dCMdGamma2(i) = 0.0
     dCMdGamma3(i) = 0.0
     dCMddGamma1(i) = 0.0
     dCMddGamma2(i) = 0.0
     dCMddGamma3(i) = 0.0
     dCMdd2Gamma1(i) = 0.0
     dCMdd2Gamma2(i) = 0.0
     dCMdd2Gamma3(i) = 0.0
     dCMddV1(i) = 0.0
     dCMddV2(i) = 0.0
     dCMddV3(i) = 0.0
     dCMdCM1(i) = 0.0
     dCMdCM2(i) = 0.0
     dCMdCM3(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     call dlinspace(numInt, d2Gamma(i), d2Gamma(i+1), dd2GammaTemp1, dd2GammaTemp2)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
        dCMTemp1(j) = R1(j)
        dCMTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCMdS(i) = dCMdS(i)+R1(j)*xTemp(j)*(dQTempdS(j)*chord*CMTemp(j))
        dCMdC(i) = dCMdC(i)+R1(j)*xTemp(j)*(QTemp(j)*CMTemp(j))
        dCMdI(i) = dCMdI(i)+R1(j)*xTemp(j)*(-(d2GammaTemp(j)*(vTemp(j) &
             *cosGamma(j))**2+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2))
        dCMdV2(i) = dCMdV2(i)+R1(j)*xTemp(j)*(dQTempdV1(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp1(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp1(j)))
        dCMdV3(i) = dCMdV3(i)+R1(j)*xTemp(j)*(dQTempdV2(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp2(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp2(j)))
        dCMdRho2(i) = dCMdRho2(i)+R1(j)*xTemp(j)*(dQTempdRho1(j)*chord*CMTemp(j))
        dCMdRho3(i) = dCMdRho3(i)+R1(j)*xTemp(j)*(dQTempdRho2(j)*chord*CMTemp(j))
        dCMdGamma2(i) = dCMdGamma2(i)+R1(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma1(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma1(j))
        dCMdGamma3(i) = dCMdGamma3(i)+R1(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma2(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma2(j))
        dCMddGamma2(i) = dCMddGamma2(i)+R1(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp1(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMddGamma3(i) = dCMddGamma3(i)+R1(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp2(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMdd2Gamma2(i) = dCMdd2Gamma2(i)+R1(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp1(j)*(vTemp(j)*cosGamma(j))**2
        dCMdd2Gamma3(i) = dCMdd2Gamma3(i)+R1(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp2(j)*(vTemp(j)*cosGamma(j))**2
        dCMddV2(i) = dCMddV2(i)+R1(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp1(j)*vTemp(j)*cosGamma(j)**2
        dCMddV3(i) = dCMddV3(i)+R1(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp2(j)*vTemp(j)*cosGamma(j)**2
        dCMdCM2(i) = dCMdCM2(i)+R1(j)*xTemp(j)*QTemp(j)*chord*dCMTemp1(j)
        dCMdCM3(i) = dCMdCM3(i)+R1(j)*xTemp(j)*QTemp(j)*chord*dCMTemp2(j)
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax
     
     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     call dlinspace(numInt, d2Gamma(i), d2Gamma(i+1), dd2GammaTemp1, dd2GammaTemp2)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
        dCMTemp1(j) = R1(j)
        dCMTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCMdS(i+1) = dCMdS(i+1)+R2(j)*xTemp(j)*(dQTempdS(j)*chord*CMTemp(j))
        dCMdC(i+1) = dCMdC(i+1)+R2(j)*xTemp(j)*(QTemp(j)*CMTemp(j))
        dCMdI(i+1) = dCMdI(i+1)+R2(j)*xTemp(j)*(-(d2GammaTemp(j)*(vTemp(j) &
             *cosGamma(j))**2+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2))
        dCMdV1(i+1) = dCMdV1(i+1)+R2(j)*xTemp(j)*(dQTempdV1(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp1(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp1(j)))
        dCMdV2(i+1) = dCMdV2(i+1)+R2(j)*xTemp(j)*(dQTempdV2(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp2(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp2(j)))
        dCMdRho1(i+1) = dCMdRho1(i+1)+R2(j)*xTemp(j)*(dQTempdRho1(j)*chord*CMTemp(j))
        dCMdRho2(i+1) = dCMdRho2(i+1)+R2(j)*xTemp(j)*(dQTempdRho2(j)*chord*CMTemp(j))
        dCMdGamma1(i+1) = dCMdGamma1(i+1)+R2(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma1(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma1(j))
        dCMdGamma2(i+1) = dCMdGamma2(i+1)+R2(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma2(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma2(j))
        dCMddGamma1(i+1) = dCMddGamma1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp1(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMddGamma2(i+1) = dCMddGamma2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp2(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMdd2Gamma1(i+1) = dCMdd2Gamma1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp1(j)*(vTemp(j)*cosGamma(j))**2
        dCMdd2Gamma2(i+1) = dCMdd2Gamma2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp2(j)*(vTemp(j)*cosGamma(j))**2
        dCMddV1(i+1) = dCMddV1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp1(j)*vTemp(j)*cosGamma(j)**2
        dCMddV2(i+1) = dCMddV2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp2(j)*vTemp(j)*cosGamma(j)**2
        dCMdCM1(i+1) = dCMdCM1(i+1)+R2(j)*xTemp(j)*QTemp(j)*chord*dCMTemp1(j)
        dCMdCM2(i+1) = dCMdCM2(i+1)+R2(j)*xTemp(j)*QTemp(j)*chord*dCMTemp2(j)
     enddo
  enddo

end subroutine getDCM

subroutine get_h_des(numElem,numInt,h_dot,x_ends,v_ends,h_ends,h)
  
  !f2py intent(in) numElem, numInt
  !f2py intent(in) h_dot
  !f2py intent(in) x_ends, v_ends, h_ends
  !f2py intent(out) h
  !f2py depend(numElem) h
  
  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: h_dot
  double precision, dimension(0:1), intent(in) :: x_ends, v_ends, h_ends
  double precision, dimension(0:numElem), intent(out) :: h

  integer :: i, j
  double precision :: dx, dv, dh
  double precision, dimension(0:numElem) :: x, v
  double precision, dimension(0:numInt) :: xTemp

  dx = (x_ends(1)-x_ends(0))/numElem
  dv = (v_ends(1)-v_ends(0))/numElem

  do i = 0,numElem
     x(i) = i*dx+x_ends(0)
     v(i) = i*dv+v_ends(0)
     h(i) = 0
  enddo

  h(0) = h_ends(0)
  do i = 0,numElem-1
     h(i+1) = h(i)
     call linspace(numInt+1,x(i),x(i+1),xTemp)
     do j = 0,numInt-1
        dh = h_dot/SQRT((v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))**2-h_dot**2)
        h(i+1) = h(i+1)+dh
     enddo
     h(i+1) = h(i+1)*(x(i+1)-x(i))/numInt
  enddo
endsubroutine get_h_des

subroutine get_h_des_d(numElem,numInt,h_dot,x_ends,v_ends,h_ends,dh_dhEnds0,dh_dhEnds1, &
     dh_dhDot, dh_dxEnds0, dh_dxEnds1, dh_dvEnds0, dh_dvEnds1)

  !f2py intent(in) numElem, numInt
  !f2py intent(in) h_dot
  !f2py intent(in) x_ends, v_ends, h_ends
  !f2py intent(out) dh_dhEnds0, dh_dhEnds1, dh_dhDot, dh_dxEnds0, dh_dxEnds1, dh_dvEnds0, dh_dvEnds1
  !f2py depend(numElem) dh_dhEnds0, dh_dhEnds1, dh_dhDot, dh_dxEnds0, dh_dxEnds1, dh_dvEnds0, dh_dvEnds1

  integer, intent(in) :: numElem, numInt
  double precision, intent(in) :: h_dot
  double precision, dimension(0:1), intent(in) :: x_ends, v_ends, h_ends
  double precision, dimension(0:numElem), intent(out) :: dh_dhEnds0, &
       dh_dhEnds1, dh_dhDot, dh_dxEnds0, dh_dxEnds1, dh_dvEnds0, dh_dvEnds1

  integer :: i, j
  double precision :: dx, dv, sqrtTerm, delta
  double precision :: ddh_dhDot, ddh_dh0, ddh_dh1, ddh_dx0, ddh_dx1
  double precision :: ddh_dv0, ddh_dv1
  double precision, dimension(0:numElem) :: x, v, h
  double precision, dimension(0:numElem) :: dx_dx0, dx_dx1, dv_dv0, dv_dv1
  double precision, dimension(0:numInt) :: xTemp, dxTemp1, dxTemp2

  dx = (x_ends(1)-x_ends(0))/numElem
  dv = (v_ends(1)-v_ends(0))/numElem

  do i = 0,numElem
     dx_dx0(i) = 1 - i/numElem
     dx_dx1(i) = i/numElem
     dv_dv0(i) = 1 - i/numElem
     dv_dv1(i) = i/numElem
     x(i) = i*dx+x_ends(0)
     v(i) = i*dv+v_ends(0)
     dh_dhEnds0(i) = 1
     dh_dhEnds1(i) = 0
     dh_dhDot(i) = 0
     dh_dxEnds0(i) = 0
     dh_dxEnds1(i) = 0
     dh_dvEnds0(i) = 0
     dh_dvEnds1(i) = 0
  enddo

  do i = 0,numElem-1

     call dlinspace(numInt+1,x(i),x(i+1),dxTemp1,dxTemp2)
     do j = 0,numInt-1
        sqrtTerm = SQRT((v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))**2-h_dot**2)
        ddh_dhDot = 1/sqrtTerm
        ddh_dhDot = ddh_dhDot + h_dot**2/(sqrtTerm**3)
        dh_dhDot(i+1) = dh_dhDot(i+1) + ddh_dhDot

        ddh_dx0 = (v(i+1)-v(i))*(dxTemp1(j)*dx_dx0(i)+dxTemp2(j)*dx_dx0(i+1))/(x(i+1)-x(i))
        ddh_dx0 = ddh_dx0 - ((v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i))**2)*(dx_dx0(i+1)-dx_dx0(i))
        ddh_dx0 = ddh_dx0 * (v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))
        ddh_dx0 = ddh_dx0 * (-h_dot/(sqrtTerm**3))
        dh_dxEnds0(i+1) = dh_dxEnds0(i+1) + ddh_dx0
        
        ddh_dx1 = (v(i+1)-v(i))*(dxTemp1(j)*dx_dx1(i)+dxTemp2(j)*dx_dx1(i+1))/(x(i+1)-x(i))
        ddh_dx1 = ddh_dx1 - ((v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i))**2)*(dx_dx1(i+1)-dx_dx1(i))
        ddh_dx1 = ddh_dx1 * (v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))
        ddh_dx1 = ddh_dx1 * (-h_dot/(sqrtTerm**3))
        dh_dxEnds1(i+1) = dh_dxEnds1(i+1) + ddh_dx1

        ddh_dv0 = (xTemp(j)/(x(i+1)-x(i)))*(dv_dv0(i+1)-dv_dv0(i))
        ddh_dv0 = ddh_dv0 + dv_dv0(i)
        ddh_dv0 = ddh_dv0 * (v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))
        ddh_dv0 = ddh_dv0 * (-h_dot/(sqrtTerm**3))
        dh_dvEnds0(i+1) = dh_dvEnds0(i+1) + ddh_dv0
        
        ddh_dv1 = (xTemp(j)/(x(i+1)-x(i)))*(dv_dv1(i+1)-dv_dv1(i))
        ddh_dv1 = ddh_dv1 + dv_dv1(i)
        ddh_dv1 = ddh_dv1 * (v(i)+(v(i+1)-v(i))*xTemp(j)/(x(i+1)-x(i)))
        ddh_dv1 = ddh_dv1 * (-h_dot/(sqrtTerm**3))
        dh_dvEnds1(i+1) = dh_dvEnds1(i+1) + ddh_dv1

        dh = h_dot/sqrtTerm
        h(i+1) = h(i+1)+dh
     enddo

     delta = (x(i+1)-x(i))/numInt
     dh_dhDot(i+1) = dh_dhDot(i+1) * delta
     dh_dvEnds0(i+1) = dh_dvEnds0(i+1) * delta
     dh_dvEnds1(i+1) = dh_dvEnds1(i+1) * delta
     dh_dxEnds0(i+1) = h(i+1)*(dx_dx0(i+1)-dx_dx0(i))/numInt + dh_dxEnds0(i+1)*delta
     dh_dxEnds1(i+1) = h(i+1)*(dx_dx1(i+1)-dx_dx1(i))/numInt + dh_dxEnds1(i+1)*delta
  enddo
endsubroutine get_h_des_d


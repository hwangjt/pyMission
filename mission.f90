! This file contains functions (to be wrapped with f2py) which are
! used with pyMission


subroutine getFinDiffCoef(M, N, x0, nCoord, coord, d)
  ! subroutine used to compute the finite element coefficients
  ! that are multiplied with discrete values to provide estimates
  ! of the derivatives
  ! these coefficients can be generated for uniform and non-uniform
  ! spacings

  implicit none

  !f2py intent(in) M, N, x0, nCoord, coord
  !f2py intent(out) d
  !f2py depend(M,N) d
  !f2py depend(nCoord) coord

  ! input/output
  integer, intent(in) :: M, N
  double precision, intent(in) :: x0
  integer, intent(in) :: nCoord
  double precision, dimension(0:nCoord), intent(in) :: coord
  double precision, dimension(0:M,0:N-1,0:N-1), intent(out) :: d

  ! variable initialization
  integer :: i = 0, j = 0, k = 0
  double precision :: c1 = 0.0, c2 = 0.0, c3 = 0.0

  do i = 0, M
     do j = 0, N-1
        do k = 0, N-1
           d(i,j,k) = 0.0
        end do
     end do
  end do

  d(0,0,0) = 1.0
  c1 = 1.0

  do j = 1, N-1
     c2 = 1.0

     do k = 0, j-1
        c3 = coord(j)-coord(k)
        c2 = c2*c3
        
        do i = 0, min(j,M)
           if (i == 0) then
              d(i,j,k) = ((coord(j)-x0)*d(i,j-1,k))/c3
           else
              d(i,j,k) = ((coord(j)-x0)*d(i,j-1,k)-i*d(i-1,j-1,k))/c3
           end if
        end do
     end do

     do i = 0, min(j,M)
        if (i == 0) then
           d(i,j,j) = -(c1/c2)*(coord(j-1)-x0)*d(i,j-1,j-1)
        else
           d(i,j,j) = (c1/c2)*(i*d(i-1,j-1,j-1)-(coord(j-1)-x0)*d(i,j-1,j-1))
        end if
     end do
     
     c1 = c2
  end do

end subroutine getFinDiffCoef

subroutine getDerivatives(numSeg, x, h, v, dv, gamma, dGamma, d2Gamma)
  ! subroutine used to compute dv/dx, gamma, dgamma/dx, d2gamma/dx2
  ! using approximations to dh/dx, d2h/dx2, d3h/dx3 generated by
  ! multiplying discrete values of h with the finite difference
  ! coefficients generated by the subroutine getFinDiffCoeff

  implicit none
  
  !f2py intent(in) numSeg
  !f2py intent(in) x, h, v
  !f2py intent(out) dv, gamma, dGamma, d2Gamma
  !f2py depend(numSeg) x, h, v, gamma, dGamma, d2Gamma

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, v
  double precision, dimension(0:numSeg-1), intent(out) :: dv, gamma, dGamma, d2Gamma
  double precision, dimension(0:numSeg-1) :: dh, d2h, d3h
  integer :: i = 0
  double precision, dimension(0:1,0:2,0:2) :: coeffs1ends
  double precision, dimension(0:2,0:3,0:3) :: coeffs2ends
  double precision, dimension(0:3,0:4,0:4) :: coeffs3ends
  double precision, dimension(0:2,0:2,0:2) :: coeffs12
  double precision, dimension(0:3,0:4,0:4) :: coeffs3

  ! use forward difference for the first 2 control points
  do i = 0,1
     call getFinDiffCoef(1,3,x(i),2,x(i:i+2),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i:i+2))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i:i+2))

     call getFinDiffCoef(2,4,x(i),3,x(i:i+3),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i:i+3))

     call getFinDiffcoef(3,5,x(i),4,x(i:i+4),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i:i+4))
  enddo

  ! use central difference for the 3rd to the 3rd-to-last
  ! control points
  do i = 2,numSeg-3
     call getFinDiffCoef(2,3,x(i),2,x(i-1:i+1),coeffs12)
     dh(i) = dot_product(coeffs12(1,2,0:2),h(i-1:i+1))
     dv(i) = dot_product(coeffs12(1,2,0:2),v(i-1:i+1))
     d2h(i) = dot_product(coeffs12(2,2,0:2),h(i-1:i+1))

     call getFinDiffCoef(3,5,x(i),4,x(i-2:i+2),coeffs3)
     d3h(i) = dot_product(coeffs3(3,4,0:4),h(i-2:i+2))
  enddo

  ! use backwards difference for the last 2 control points
  do i = numSeg-2,numSeg-1
     call getFinDiffCoef(1,3,x(i),2,x(i-2:i),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i-2:i))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i-2:i))

     call getFinDiffCoef(2,4,x(i),3,x(i-3:i),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i-3:i))
     
     call getFinDiffCoef(3,5,x(i),4,x(i-4:i),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i-4:i))
  enddo

  ! compute gamma, dgamma/dx, and d2gamma/dx2 using dh/dx,
  ! d2h/dx2, and d3h/dx3
  gamma = atan(dh)
  dGamma = d2h/(dh*dh+1)
  d2Gamma = (((dh*dh+1)*d3h-2*dh*d2h*d2h)/((dh*dh+1)*(dh*dh+1)))

end subroutine getDerivatives

subroutine getDDerivatives(numSeg, x, h, v, ddhdh, ddvdv, dgammadh, dd2hdh, &
     ddGammadh, dd3hdh, dd2Gammadh)
  ! computes the derivatives of dh/dx, dv/dx, gamma, d2h/dx2, dgamma/dx,
  ! d3h/dx3, d2gamma/dx2 with respect to h and v
  
  !f2py intent(in) numSeg
  !f2py intent(in) x, h, v
  !f2py intent(out) ddhdh, ddvdv, dgammadh, dd2hdh, ddGammadh, dd3hdh, dd2Gammadh
  !f2py depend(numSeg) x, h, v, ddhdh, ddvdv, dgammadh, dd2hdh, ddGammadh, dd3hdh, dd2Gammadh

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, v
  double precision, dimension(0:numSeg-1,0:2), intent(out) :: ddhdh, ddvdv, dgammadh
  double precision, dimension(0:numSeg-1,0:3), intent(out) :: dd2hdh, ddGammadh
  double precision, dimension(0:numSeg-1,0:4), intent(out) :: dd3hdh, dd2Gammadh
  
  integer :: i = 0
  double precision, dimension(0:numSeg-1) :: dh, dv, d2h, d3h
  double precision, dimension(0:1,0:2,0:2) :: coeffs1ends
  double precision, dimension(0:2,0:3,0:3) :: coeffs2ends
  double precision, dimension(0:3,0:4,0:4) :: coeffs3ends
  double precision, dimension(0:2,0:2,0:2) :: coeffs12
  double precision, dimension(0:3,0:4,0:4) :: coeffs3
  
  
  do i = 0,1
     call getFinDiffCoef(1,3,x(i),2,x(i:i+2),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i:i+2))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i:i+2))
     do j = 0,2
        ddhdh(i,j) = coeffs1ends(1,2,j)
        ddvdv(i,j) = coeffs1ends(1,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
     enddo

     call getFinDiffCoef(2,4,x(i),3,x(i:i+3),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i:i+3))
     do j = 0,3
        dd2hdh(i,j) = coeffs2ends(2,3,j)
     enddo

     do j = 0,2
        ddGammadh(i,j) = (1/(dh(i)**2+1))*dd2hdh(i,j) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo
     ddGammadh(i,3) = (1/(dh(i)**2+1))*dd2hdh(i,j)

     call getFinDiffCoef(3,5,x(i),4,x(i:i+4),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i:i+4))
     do j = 0,4
        dd3hdh(i,j) = coeffs3ends(3,4,j)
     enddo

     do j = 0,2
        dd2Gammadh(i,j) = 2*dh(i)*ddhdh(i,j)*(d3h(i)/(dh(i)**2+1)**2) &
             +(1/(dh(i)**2+1))*dd3hdh(i,j) &
             -4*dh(i)*ddhdh(i,j)*((dh(i)**2+1)*d3h(i))/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
     dd2Gammadh(i,3) = (1/(dh(i)**2+1))*dd3hdh(i,3) &
          -4*dh(i)*dd2hdh(i,3)*d2h(i)/(dh(i)**2+1)**2
     dd2Gammadh(i,4) = (1/(dh(i)**2+1))*dd3hdh(i,4)
  enddo

  do i = 2,numSeg-3
     call getFinDiffCoef(2,3,x(i),2,x(i-1:i+1),coeffs12)
     dh(i) = dot_product(coeffs12(1,2,0:2),h(i-1:i+1))
     dv(i) = dot_product(coeffs12(1,2,0:2),v(i-1:i+1))
     d2h(i) = dot_product(coeffs12(2,2,0:2),h(i-1:i+1))
     do j = 0,2
        ddhdh(i,j) = coeffs12(1,2,j)
        ddvdv(i,j) = coeffs12(1,2,j)
        dd2hdh(i,j) = coeffs12(2,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
        ddGammadh(i,j) = (1/(dh(i)**2+1))*dd2hdh(i,j) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo

     call getFinDiffCoef(3,5,x(i),4,x(i-2:i+2),coeffs3)
     d3h(i) = dot_product(coeffs3(3,4,0:4),h(i-2:i+2))
     do j = 0,4
        dd3hdh(i,j) = coeffs3(3,4,j)
     enddo

     dd2Gammadh(i,0) = (1/(dh(i)**2+1))*dd3hdh(i,0)
     do j = 0,2
        dd2Gammadh(i,j+1) = 2*dh(i)*ddhdh(i,j)*d3h(i)/(dh(i)**2+1)**2 &
             +(1/(dh(i)**2+1))*dd3hdh(i,j+1) &
             -4*dh(i)*ddhdh(i,j)*(dh(i)**2+1)*d3h(i)/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
     dd2Gammadh(i,4) = (1/(dh(i)**2+1))*dd3hdh(i,4)

  enddo

  do i = numSeg-2,numSeg-1
     call getFinDiffCoef(1,3,x(i),2,x(i-2:i),coeffs1ends)
     dh(i) = dot_product(coeffs1ends(1,2,0:2),h(i-2:i))
     dv(i) = dot_product(coeffs1ends(1,2,0:2),v(i-2:i))
     do j = 0,2
        ddhdh(i,j) = coeffs1ends(1,2,j)
        ddvdv(i,j) = coeffs1ends(1,2,j)
        dgammadh(i,j) = (1/(dh(i)**2+1))*ddhdh(i,j)
     enddo

     call getFinDiffCoef(2,4,x(i),3,x(i-3:i),coeffs2ends)
     d2h(i) = dot_product(coeffs2ends(2,3,0:3),h(i-3:i))
     do j = 0,3
        dd2hdh(i,j) = coeffs2ends(2,3,j)
     enddo

     ddGammadh(i,0) = (1/(dh(i)**2+1))*dd2hdh(i,0)
     do j = 0,2
        ddGammadh(i,j+1) = (1/(dh(i)**2+1))*dd2hdh(i,j+1) &
             -2*dh(i)*d2h(i)*ddhdh(i,j)*(1/(dh(i)**2+1)**2)
     enddo

     call getFinDiffCoef(3,5,x(i),4,x(i-4:i),coeffs3ends)
     d3h(i) = dot_product(coeffs3ends(3,4,0:4),h(i-4:i))
     do j = 0,4
        dd3hdh(i,j) = coeffs3ends(3,4,j)
     enddo

     dd2Gammadh(i,0) = (1/(dh(i)**2+1))*dd3hdh(i,0)
     dd2Gammadh(i,1) = (1/(dh(i)**2+1))*dd3hdh(i,1) &
          -4*dh(i)*dd2hdh(i,0)*d2h(i)/(dh(i)**2+1)**2
     do j = 0,2
        dd2Gammadh(i,j+2) = 2*dh(i)*ddhdh(i,j)*d3h(i)/(dh(i)**2+1)**2 &
             +(1/(dh(i)**2+1))*dd3hdh(i,j+2) &
             -4*dh(i)*ddhdh(i,j)*(dh(i)**2+1)*d3h(i)/(dh(i)**2+1)**3 &
             -2*ddhdh(i,j)*d2h(i)**2*(1/(dh(i)**2+1)**2) &
             -4*dh(i)*dd2hdh(i,j+1)*d2h(i)/(dh(i)**2+1)**2 &
             +8*dh(i)**2*ddhdh(i,j)*d2h(i)**2/(dh(i)**2+1)**3
     enddo
  enddo
end subroutine getDDerivatives

subroutine getAlphaRes(numSeg, alpha, eta, CL, alphaRes)
  ! compute the CL residual as defined by the linear aerodynamics

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CL
  !f2py intent(out) alphaRes
  !f2py depend(numSeg) alpha, eta, CL, alphaRes

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CL
  double precision, dimension(0:numSeg-1), intent(out) :: alphaRes

  alphaRes = alpha - (1/4.24)*(CL-0.26-0.27*eta)

end subroutine getAlphaRes

subroutine getDAlpha(numSeg, alpha, eta, CL, dalpha, deta, dCL)
  ! compute the derivatives of residuals of CL wrt alpha, eta, and CL

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CL
  !f2py intent(out) dalpha, deta, dCL
  !f2py depend(numSeg) alpha, eta, CL, dalpha, deta, dCL

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CL
  double precision, dimension(0:numSeg-1), intent(out) :: dalpha, deta, dCL

  integer :: i = 0

  do i = 0,numSeg-1
     dalpha(i) = 1.0
     deta(i) = 0.27/4.24
     dCL(i) = -1/4.24
  enddo

end subroutine getDAlpha

subroutine getCDRes(numSeg, AR, e, CL, CD, CDRes)
  ! compute the residuals of CD using simple drag polar

  !f2py intent(in) numSeg
  !f2py intent(in) AR, e
  !f2py intent(in) CL, CD
  !f2py intent(out) CDRes
  !f2py depend(numSeg) CL, CD, CDRes

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, intent(in) :: AR, e
  double precision, dimension(0:numSeg-1), intent(in) :: CL, CD
  double precision, dimension(0:numSeg-1), intent(out) :: CDRes
  
  double precision, parameter :: PI = 3.14159265359

  CDRes = CD - (0.018 + CL**2/(PI*AR*e))

end subroutine getCDRes

subroutine getDCD(numSeg, AR, e, CL, CD, dAR, de, dCL, dCD)
  ! compute the derivatives of residuals of CD wrt AR, e, CL, and CD

  !f2py intent(in) numSeg
  !f2py intent(in) AR, e
  !f2py intent(in) CL, CD
  !f2py intent(out) dAR, de, dCL, dCD
  !f2py depend(numSeg) CL, CD, dAR, de, dCL, dCD

  ! Input/Output
  integer, intent(in) :: numSeg
  double precision, intent(in) :: AR, e
  double precision, dimension(0:numSeg-1), intent(in) :: CL, CD
  double precision, dimension(0:numSeg-1), intent(out) :: dAR, de, dCL, dCD
  
  integer :: i = 0
  double precision, parameter :: PI = 3.14159254359

  do i = 0,numSeg-1
     dAR(i) = CL(i)**2/(PI*e*AR**2)
     de(i) = CL(i)**2/(PI*AR*e**2)
     dCL(i) = -2*CL(i)/(PI*AR*e)
     dCD(i) = 1.0
  enddo

end subroutine getDCD

subroutine getEtaRes(numSeg, alpha, eta, CM, etaRes)
  ! compute the residuals of CM (pitching moment coefficient)

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CM
  !f2py intent(out) etaRes
  !f2py depend(numSeg) alpha, eta, CM, etaRes

  !Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CM
  double precision, dimension(0:numSeg-1), intent(out) :: etaRes

  etaRes = eta - (1/1.06)*(0.63*alpha - CM)

end subroutine getEtaRes

subroutine getDEta(numSeg, alpha, eta, CM, dalpha, deta, dCM)
  ! compute the derivatives of residuals of CM wrt alpha, eta, CM

  !f2py intent(in) numSeg
  !f2py intent(in) alpha, eta, CM
  !f2py intent(out) dalpha, deta, dCM
  !f2py depend(numSeg) alpha, eta, CM, dalpha, deta, dCM

  !Input/Output
  integer, intent(in) :: numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: alpha, eta, CM
  double precision, dimension(0:numSeg-1), intent(out) :: dalpha, deta, dCM

  integer :: i = 0

  do i = 0,numSeg-1
     dalpha(i) = -0.63/1.06
     deta(i) = 1.0
     dCM(i) = 1/1.06
  enddo

end subroutine getDEta

subroutine linspace(n, x0, x1, y)
  ! fortran implementation of linspace function

  !Input/Output
  integer, intent(in) :: n
  double precision, intent(in) :: x0, x1
  double precision, dimension(0:n-1), intent(out) :: y

  double precision :: dx
  integer :: i

  dx = (x1-x0)/(n-1)

  do i = 0,n-1
     y(i) = x0 + dx*i
  enddo

end subroutine linspace

subroutine dlinspace(n, x0, x1, dy1, dy2)
  ! computes the derivatives of the output of linspace function
  ! wrt to the two inputs x0, and x1

  !Input/Output
  integer, intent(in) :: n
  double precision, intent(in) :: x0, x1
  double precision, dimension(0:n-1), intent(out) :: dy1, dy2

  integer :: i

  do i = 0,n-1
     dy1(i) = (1-real(i)/real(n-1))
     dy2(i) = real(i)/real(n-1)
  enddo

end subroutine dlinspace

subroutine getTauRes(numSeg, cThrustSL, x, h, tau, Thrust, tauRes)
  ! computes the residuals of the thrust using a simple propulsion model

  !f2py intent(in) numSeg
  !f2py intent(in) cThrustSL
  !f2py intent(in) x, h, tau, Thrust
  !f2py intent(out) tauRes
  !f2py depend(numSeg) x, h, tau, Thrust, tauRes

  integer, intent(in) :: numSeg
  double precision, intent(in) :: cThrustSL
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, tau, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: tauRes

  integer :: i = 0
  double precision, dimension(0:numSeg-1) :: cThrust

  do i = 0,numSeg-1
     cThrust(i) = cThrustSL - 0.072*h(i)
     tauRes(i) = tau(i) - Thrust(i)/cThrust(i)
  enddo

end subroutine getTauRes

subroutine getDTau(numSeg, cThrustSL, x, h, tau, Thrust, dCThrustSL, dh, dtau, dThrust)
  ! computes the derivatives of the residuals of thrust wrt
  ! propulsion parameters, h, tau, and thrust

  !f2py intent(in) numSeg
  !f2py intent(in) cThrustSL
  !f2py intent(in) x, h, tau, Thrust
  !f2py intent(out) dCThrustSL, dh, dtau, dThrust
  !f2py depend(numSeg) x, h, tau, Thrust, dCThrustSL, dh, dtau, dThrust

  integer, intent(in) :: numSeg
  double precision, intent(in) :: cThrustSL
  double precision, dimension(0:numSeg-1), intent(in) :: x, h, tau, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: dCThrustSL, dh, dtau, dThrust

  integer :: i = 0
  double precision, dimension(0:numseg-1) :: cThrust

  do i = 0,numSeg-1
     cThrust(i) = cThrustSL - 0.072*h(i)
     dCThrustSL(i) = 1/(cThrust(i)**2)
     dh(i) = -0.072/(cThrust(i)**2)
     dtau(i) = 1.0
     dThrust(i) = -1/cThrust(i)
  enddo

end subroutine getDTau

subroutine getWfRes(numInt, numSeg, x, v, gamma, tau, Thrust, cT, g, R1, R2, WfIn, WfRes)
  ! computes the residuals of the fuel weight for each segment
  ! using a forward Euler scheme implemented backwards from the
  ! end of the mission
  ! the current initial condition is set to be 0 fuel at the end
  ! of the mission

  !f2py intent(in) numInt, numSeg
  !f2py intent(in) x, v, gamma, tau, Thrust, cT
  !f2py intent(in) g
  !f2py intent(in) R1, R2
  !f2py intent(in) WfIn
  !f2py intent(out) WfRes
  !f2py depend(numSeg) x, v, gamma, tau, Thrust, cT, WfIn
  !f2py depend(numInt) R1, R2

  !Input/Output
  integer, intent(in) :: numInt, numSeg
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, gamma, tau
  double precision, dimension(0:numSeg-1), intent(in) :: Thrust, cT
  double precision, intent(in) :: g
  double precision, dimension(0:numInt-1), intent(in) :: R1, R2
  double precision, dimension(0:numSeg-1), intent(in) :: WfIn
  double precision, dimension(0:numSeg-1), intent(out) :: WfRes

  double precision, dimension(0:numSeg-1) :: Wf
  double precision, dimension(0:numInt-1,0:numSeg-1) :: estWf
  double precision, dimension(0:numInt-1) :: vTemp, xTemp, cTTemp, gammaTemp, cosGamma
  double precision :: dx, WfTemp
  integer :: i = 0, j = 0, k = 0, l = 0

  do i = 0,numInt-1
     do j = 0,numSeg-1
        estWf(i,j) = 0.0
     enddo
  enddo

  do i = 0,numSeg-1
     Wf(i) = 0.0
  enddo

  do i = 0,numSeg-2

     j = numSeg-2-i
     call linspace(numInt, v(j), v(j+1), vTemp)
     dx = (x(j+1)-x(j))/real(numInt)

     do k = 0,numInt-1
        xTemp(k) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx
     call linspace(numInt, cT(j), cT(j+1), cTTemp)
     call linspace(numInt, gamma(j), gamma(j+1), gammaTemp)
     cosGamma = cos(gammaTemp)

     do k = 0,numInt-1
        WfTemp = ((cTTemp(k)*Thrust(j+1)*R1(k)+cTTemp(k)*Thrust(j)*R2(k)))
        WfTemp = WfTemp*xTemp(k)/(vTemp(k)*cosGamma(k))
        estWf(k,j) = estWf(k,j) + WfTemp
     enddo
  enddo

  do i = 0,numSeg-1
     do j = 0,numInt-1
        Wf(i) = Wf(i) + estWf(j,i)
     enddo
     Wf(i) = Wf(i) * g
  enddo

  do i = 0,numSeg-2
     j = numSeg-2-i
     Wf(j) = Wf(j) + WfIn(j+1)
  enddo

  WfRes = WfIn - Wf

end subroutine getWfRes

subroutine getDWf(numSeg, numInt, g, x, v, gamma, tau, Thrust, cT, R1, R2, &
     dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2, dWf1, dWf2)
  ! computes the derivatives of the residuals of fuel weights wrt
  ! propulsion parameters, thrust, v, gamma, and fuel weight
  ! the resultant jacobian is bi-diagonal, and is stored in 2
  ! vectors for each derivative, ie, d___1 and d___2

  !f2py intent(in) numSeg, numInt
  !f2py intent(in) g
  !f2py intent(in) x, v, gamma, tau, Thrust, cT
  !f2py intent(in) R1, R2
  !f2py intent(out) dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2, dWf1, dWf2
  !f2py depend(numSeg) x, v, gamma, tau, Thrust, cT, dCT1, dCT2, dThrust1, dThrust2, dV1, dV2, dGamma1, dGamma2, dWf
  !f2py depend(numInt) R1, R2

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, gamma, tau
  double precision, dimension(0:numSeg-1), intent(in) :: Thrust, cT
  double precision, dimension(0:numInt-1), intent(in) :: R1, R2
  double precision, dimension(0:numSeg-1), intent(out) :: dCT1, dCT2, dThrust1, dThrust2
  double precision, dimension(0:numSeg-1), intent(out) :: dV1, dV2, dGamma1, dGamma2, dWf1, dWf2

  integer :: i = 0, j = 0, k = 0
  double precision :: deltax
  double precision :: dWfTempdCT1, dWfTempdCT2, dWfTempdThrust1, dWfTempdThrust2
  double precision :: dWfTempdV1, dWfTempdV2
  double precision :: dWfTempdGamma1, dWfTempdGamma2
  double precision, dimension(0:numInt-1) :: vTemp, xTemp, cTTemp, gammaTemp, cosGamma
  double precision, dimension(0:numInt-1) :: dVTemp1, dVTemp2, dCTTemp1, dCTTemp2, dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2

  do i = 0,numSeg-1
     dCT1(i) = 0.0
     dCT2(i) = 0.0
     dThrust1(i) = 0.0
     dThrust2(i) = 0.0
     dV1(i) = 0.0
     dV2(i) = 0.0
     dGamma1(i) = 0.0
     dGamma2(i) = 0.0
     dWf1(i) = 1.0
     dWf2(i) = -1.0
  enddo

  dWf2(numSeg-1) = 0.0

  do i = 0,numSeg-2

     j = numSeg-2-i
     call linspace(numInt, v(j), v(j+1), vTemp)
     call dlinspace(numInt, v(j), v(j+1), dVTemp1, dVTemp2)
     deltax = (x(j+1)-x(j))/real(numInt)

     do k = 0,numInt-1
        xTemp(k) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, cT(j), cT(j+1), cTTemp)
     call dlinspace(numInt, cT(j), cT(j+1), dCTTemp1, dCTTemp2)
     call linspace(numInt, gamma(j), gamma(j+1), gammaTemp)
     call dlinspace(numInt, gamma(j), gamma(j+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2

     do k = 0,numInt-1

        dWfTempdCT1 = (Thrust(j+1)*R1(k)+Thrust(j)*R2(k))*xTemp(k)/(vTemp(k)*cosGamma(k))
        dWfTempdCT2 = dWfTempdCT1
        dWfTempdCT1 = dWfTempdCT1*dCTTemp1(k)
        dWfTempdCT2 = dWfTempdCT2*dCTTemp2(k)
        dCT1(j) = dCT1(j)-dWfTempdCT1*g
        dCT2(j) = dCT2(j)-dWfTempdCT2*g
        
        dWfTempdThrust1 = cTTemp(k)*R2(k)*xTemp(k)/(vTemp(k)*cosGamma(k))
        dWfTempdThrust2 = cTTemp(k)*R1(k)*xTemp(k)/(vTemp(k)*cosGamma(k))
        dThrust1(j) = dThrust1(j)-dWfTempdThrust1*g
        dThrust2(j) = dThrust2(j)-dWfTempdThrust2*g

        dWfTempdV1 = -(cTTemp(k)*Thrust(j+1)*R1(k)+cTTemp(k)*Thrust(j)*R2(k))/(cosGamma(k)*vTemp(k)**2)*xTemp(k)
        dWfTempdV2 = dWfTempdV1
        dWfTempdV1 = dWfTempdV1*dVTemp1(k)
        dWfTempdV2 = dWfTempdV2*dVTemp2(k)
        dV1(j) = dV1(j)-dWfTempdV1*g
        dV2(j) = dV2(j)-dWfTempdV2*g

        dWfTempdGamma1 = -(cTTemp(k)*Thrust(j+1)*R1(k)+cTTemp(k)*Thrust(j)*R2(k))/(vTemp(k)*cosGamma(k)**2)*xTemp(k)
        dWfTempdGamma2 = dWfTempdGamma1
        dWfTempdGamma1 = dWfTempdGamma1*dCosGamma1(k)
        dWfTempdGamma2 = dWfTempdGamma2*dCosGamma2(k)
        dGamma1(j) = dGamma1(j)-dWfTempdGamma1*g
        dGamma2(j) = dGamma2(j)-dWfTempdGamma2*g
     enddo
  enddo
       
end subroutine getDWf

subroutine getCLRes(numSeg, numInt, Wac, S, g, x, v, rho, CL, Wf, gamma, &
     Thrust, alpha, dGamma, alphaRes)
  ! compute the residuals for alpha using the governing flight equation
  ! the flight equation is integrated, and the resultant value is 
  ! determined to be the residual for alpha
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) Wac, S, g
  !f2py intent(in) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  !f2py intent(out) alphaRes
  !f2py depend(numSeg) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma, alphaRes

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: Wac, S, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  double precision, dimension(0:numSeg-1), intent(out) :: alphaRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: CLTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numSeg-1,0:numInt-1) :: alphaTemp

  do i = 0,numSeg-1
     do j = 0,numInt-1
        alphaTemp(i,j) = 0.0
     enddo
     alphaRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)     
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        temp = temp-sin(aTemp(j))*tTemp(j)
        temp = temp+WTemp(j)*(1/g)*vTemp(j)*vTemp(j)*cosGamma(j)*dGammaTemp(j)
        temp = temp*R1(j)*xTemp(j)
        alphaTemp(i,j) = alphaTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)

     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        temp = temp-sin(aTemp(j))*tTemp(j)
        temp = temp+WTemp(j)*(1/g)*vTemp(j)*vTemp(j)*cosGamma(j)*dGammaTemp(j)
        temp = temp*R2(j)*xTemp(j)
        alphaTemp(i+1,j) = alphaTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numSeg-1
     do j = 0,numInt-1
        alphaRes(i) = alphaRes(i) + alphaTemp(i,j)
     enddo
  enddo

end subroutine getCLRes

subroutine getDCL(numSeg, numInt, Wac, S, g, x, v, rho, CL, Wf, gamma, &
     Thrust, alpha, dGamma, dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, &
     dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, &
     dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3)
  ! compute the derivatives of the residuals of alpha wrt gamma,
  ! empty weight, S, v, rho, CL, fuel weight, gamma, thrust,
  ! alpha, dgamma/dx
  ! the jacobian structure is tri-diagonal, and is stored in 3
  ! vectors for each derivative

  !f2py intent(in) numSeg, numInt
  !f2py intent(in) Wac, S, g
  !f2py intent(in) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  !f2py intent(out) dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, dCLdCL1, dCLdCL2, dCLdCL3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3
  !f2py depend(numSeg) x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma, dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3, dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1, dCLdGamma2, dCLdGamma3, dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3, dCLddGamma1, dCLddGamma2, dCLddGamma3

  ! Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: Wac, S, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, CL, Wf, gamma, Thrust, alpha, dGamma
  double precision, dimension(0:numSeg-1), intent(out) :: dCLdWac, dCLdS, dCLdV1, dCLdV2, dCLdV3, dCLdRho1, dCLdRho2, dCLdRho3
  double precision, dimension(0:numSeg-1), intent(out) :: dCLdCL1, dCLdCL2, dCLdCL3, dCLdWf1, dCLdWf2, dCLdWf3, dCLdGamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCLdGamma2, dCLdGamma3
  double precision, dimension(0:numSeg-1), intent(out) :: dCLdThrust1, dCLdThrust2, dCLdThrust3, dCLdAlpha1, dCLdAlpha2, dCLdAlpha3
  double precision, dimension(0:numSeg-1), intent(out) :: dCLddGamma1, dCLddGamma2, dCLddGamma3

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: CLTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numInt-1) :: dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2
  double precision, dimension(0:numInt-1) :: dQTempdS
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2
  double precision, dimension(0:numInt-1) :: dVTemp1, dVTemp2
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: ddGammaTemp1, ddGammaTemp2
  double precision, dimension(0:numInt-1) :: dCLTemp1, dCLTemp2
  double precision, dimension(0:numInt-1) :: dWTempdWf1, dWTempdWf2
  double precision, dimension(0:numInt-1) :: dWTempdWac, dATemp1, dATemp2
  double precision, dimension(0:numInt-1) :: dTTemp1, dTTemp2

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-1
     dCLdWac(i) = 0.0
     dCLdS(i) = 0.0
     dCLdV1(i) = 0.0
     dCLdV2(i) = 0.0
     dCLdV3(i) = 0.0
     dCLdRho1(i) = 0.0
     dCLdRho2(i) = 0.0
     dCLdRho3(i) = 0.0
     dCLdCL1(i) = 0.0
     dCLdCL2(i) = 0.0
     dCLdCL3(i) = 0.0
     dCLdWf1(i) = 0.0
     dCLdWf2(i) = 0.0
     dCLdWf3(i) = 0.0
     dCLdGamma1(i) = 0.0
     dCLdGamma2(i) = 0.0
     dCLdGamma3(i) = 0.0
     dCLdThrust1(i) = 0.0
     dCLdThrust2(i) = 0.0
     dCLdThrust3(i) = 0.0
     dCLdAlpha1(i) = 0.0
     dCLdAlpha2(i) = 0.0
     dCLdAlpha3(i) = 0.0
     dCLddGamma1(i) = 0.0
     dCLddGamma2(i) = 0.0
     dCLddGamma3(i) = 0.0
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        dQTempdRho1(j) = 0.5*vTemp(j)**2*S*dRhoTemp1(j)
        dQTempdRho2(j) = 0.5*vTemp(j)**2*S*dRhoTemp2(j)
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        dCLTemp1(j) = R1(j)
        dCLTemp2(j) = R2(j)
        
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0

        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)

        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCLdWac(i) = dCLdWac(i)+R1(j)*xTemp(j)*(cosGamma(j)*dWTempdWac(j) &
             +(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j)*dWTempdWac(j))
        dCLdS(i) = dCLdS(i)-R1(j)*xTemp(j)*(dQTempdS(j)*CLTemp(j))
        dCLdV2(i) = dCLdV2(i)+R1(j)*xTemp(j)*(-dQTempdV1(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp1(j)*cosGamma(j)*dGammaTemp(j))
        dCLdV3(i) = dCLdV3(i)+R1(j)*xTemp(j)*(-dQTempdV2(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp2(j)*cosGamma(j)*dGammaTemp(j))
        dCLdRho2(i) = dCLdRho2(i)+R1(j)*xTemp(j)*(-dQTempdRho1(j)*CLTemp(j))
        dCLdRho3(i) = dCLdRho3(i)+R1(j)*xTemp(j)*(-dQTempdRho2(j)*CLTemp(j))
        dCLdCL2(i) = dCLdCL2(i)+R1(j)*xTemp(j)*(-QTemp(j)*dCLTemp1(j))
        dCLdCL3(i) = dCLdCL3(i)+R1(j)*xTemp(j)*(-QTemp(j)*dCLTemp2(j))
        dCLdWf2(i) = dCLdWf2(i)+R1(j)*xTemp(j)*(dWTempdWf1(j)*cosGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdWf3(i) = dCLdWf3(i)+R1(j)*xTemp(j)*(dWTempdWf2(j)*cosGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdGamma2(i) = dCLdGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*dCosGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma1(j)*dGammaTemp(j))
        dCLdGamma3(i) = dCLdGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*dCosGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma2(j)*dGammaTemp(j))
        dCLdThrust2(i) = dCLdThrust2(i)+R1(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp1(j))
        dCLdThrust3(i) = dCLdThrust3(i)+R1(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp2(j))
        dCLdAlpha2(i) = dCLdAlpha2(i)+R1(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp1(j))
        dCLdAlpha3(i) = dCLdAlpha3(i)+R1(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp2(j))
        dCLddGamma2(i) = dCLddGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp1(j))
        dCLddGamma3(i) = dCLddGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp2(j))
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp1, dGammaTemp2)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        dCLTemp1(j) = R1(j)
        dCLTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCLdWac(i+1) = dCLdWac(i+1)+R2(j)*xTemp(j)*(cosGamma(j)*dWTempdWac(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdS(i+1) = dCLdS(i+1)+R2(j)*xTemp(j)*(-dQTempdS(j)*CLTemp(j))
        dCLdV1(i+1) = dCLdV1(i+1)+R2(j)*xTemp(j)*(-dQTempdV1(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp1(j)*cosGamma(j)*dGammaTemp(j))
        dCLdV2(i+1) = dCLdV2(i+1)+R2(j)*xTemp(j)*(-dQTempdV2(j)*CLTemp(j) &
             +(2/g)*WTemp(j)*vTemp(j)*dVTemp2(j)*cosGamma(j)*dGammaTemp(j))
        dCLdRho1(i+1) = dCLdRho1(i+1)+R2(j)*xTemp(j)*(-dQTempdRho1(j)*CLTemp(j))
        dCLdRho2(i+1) = dCLdRho2(i+1)+R2(j)*xTemp(j)*(-dQTempdRho2(j)*CLTemp(j))
        dCLdCL1(i+1) = dCLdCL1(i+1)+R2(j)*xTemp(j)*(-QTemp(j)*dCLTemp1(j))
        dCLdCL2(i+1) = dCLdCL2(i+1)+R2(j)*xTemp(j)*(-QTemp(j)*dCLTemp2(j))
        dCLdWf1(i+1) = dCLdWf1(i+1)+R2(j)*xTemp(j)*(dWTempdWf1(j)*cosGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdWf2(i+1) = dCLdWf2(i+1)+R2(j)*xTemp(j)*(dWTempdWf2(j)*cosGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)**2*cosGamma(j)*dGammaTemp(j))
        dCLdGamma1(i+1) = dCLdGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dCosGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma1(j)*dGammaTemp(j))
        dCLdGamma2(i+1) = dCLdGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dCosGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)**2*dCosGamma2(j)*dGammaTemp(j))
        dCLdThrust1(i+1) = dCLdThrust1(i+1)+R2(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp1(j))
        dCLdThrust2(i+1) = dCLdThrust2(i+1)+R2(j)*xTemp(j)*(-sin(aTemp(j)) &
             *dTTemp2(j))
        dCLdAlpha1(i+1) = dCLdAlpha1(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp1(j))
        dCLdAlpha2(i+1) = dCLdAlpha2(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(j)) &
             *tTemp(j)*dATemp2(j))
        dCLddGamma1(i+1) = dCLddGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp1(j))
        dCLddGamma2(i+1) = dCLddGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g) &
             *vTemp(j)**2*cosGamma(j)*ddGammaTemp2(j))
     enddo
  enddo

end subroutine getDCL

subroutine getThrustRes(numSeg, numInt, S, Wac, g, x, v, rho, gamma, dv, CD, Wf, &
     alpha, Thrust, ThrustRes)
  ! compute the residuals for tau by integrating the T = D flight equation
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, Wac, g
  !f2py intent(in) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust
  !f2py intent(out) ThrustRes
  !f2py depend(numSeg) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust, ThrustRes

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, Wac, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dv
  double precision, dimension(0:numSeg-1), intent(in) :: CD, Wf, alpha, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: ThrustRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp, dvTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, sinGamma
  double precision, dimension(0:numInt-1) :: CDTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numSeg-1,0:numInt-1) :: tauTemp

  do i = 0,numSeg-1
     do j = 0,numInt-1
        tauTemp(i,j) = 0.0
     enddo
     ThrustRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-cos(aTemp(j))*tTemp(j))
        temp = temp+QTemp(j)*CDTemp(j)
        temp = temp+WTemp(j)*sinGamma(j)
        temp = temp+WTemp(j)*(1/g)*vTemp(j)*cosgamma(j)*dvTemp(j)
        temp = temp*R1(j)*xTemp(j)
        tauTemp(i,j) = tauTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = (-cos(aTemp(j))*tTemp(j)+QTemp(j)*CDTemp(j))
        temp = temp+WTemp(j)*sinGamma(j)+WTemp(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j)
        temp = temp*R2(j)*xTemp(j)
        tauTemp(i+1,j) = tauTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numSeg-1
     do j = 0,numInt-1
        ThrustRes(i) = ThrustRes(i) + tauTemp(i,j)
     enddo
  enddo

end subroutine getThrustRes

subroutine getDThrust(numSeg, numInt, S, Wac, g, x, v, rho, gamma, dv, CD, Wf, &
     alpha, Thrust, dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, &
     dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, &
     dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3)
  ! compute the derivatives of residuals of tau wrt S, empty weight,
  ! v, rho, gamma, dv/dx, CD, fuel weight, alpha, and thrust
  ! the jacobians are tri-diagonal, and are stored in 3 vectors
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, Wac, g
  !f2py intent(in) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust
  !f2py intent(out) dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3
  !f2py depend(numSeg) x, v, rho, gamma, dv, CD, Wf, alpha, Thrust, dTdS, dTdWac, dTdV1, dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3, dTdGamma1, dTdGamma2, dTdGamma3, dTddV1, dTddV2, dTddV3, dTdCD1, dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3, dTdAlpha1, dTdAlpha2, dTdAlpha3, dTdThrust1, dTdThrust2, dTdThrust3

  ! Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, Wac, g
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dv
  double precision, dimension(0:numSeg-1), intent(in) :: CD, Wf, alpha, Thrust
  double precision, dimension(0:numSeg-1), intent(out) :: dTdS, dTdWac, dTdV1
  double precision, dimension(0:numSeg-1), intent(out) :: dTdV2, dTdV3, dTdRho1, dTdRho2, dTdRho3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdGamma1, dTdGamma2, dTdGamma3
  double precision, dimension(0:numSeg-1), intent(out) :: dTddV1, dTddV2, dTddV3, dTdCD1
  double precision, dimension(0:numSeg-1), intent(out) :: dTdCD2, dTdCD3, dTdWf1, dTdWf2, dTdWf3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdAlpha1, dTdAlpha2, dTdAlpha3
  double precision, dimension(0:numSeg-1), intent(out) :: dTdThrust1, dTdThrust2, dTdThrust3

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp, dvTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, sinGamma
  double precision, dimension(0:numInt-1) :: CDTemp, WTemp, aTemp, tTemp
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2, dVTemp1
  double precision, dimension(0:numInt-1) :: dVTemp2, dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2, dQTempdS
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: dSinGamma1, dSinGamma2
  double precision, dimension(0:numInt-1) :: ddVTemp1, ddVTemp2
  double precision, dimension(0:numInt-1) :: dCDTemp1, dCDTemp2
  double precision, dimension(0:numInt-1) :: dWTempdWf1, dWTempdWf2, dWTempdWac
  double precision, dimension(0:numInt-1) :: dATemp1, dATemp2, dTTemp1, dTTemp2
  
  do i = 0, numSeg-1
     dTdS(i) = 0.0
     dTdWac(i) = 0.0
     dTdV1(i) = 0.0
     dTdV2(i) = 0.0
     dTdV3(i) = 0.0
     dTdRho1(i) = 0.0
     dTdRho2(i) = 0.0
     dTdRho3(i) = 0.0
     dTdGamma1(i) = 0.0
     dTdGamma2(i) = 0.0
     dTdGamma3(i) = 0.0
     dTddV1(i) = 0.0
     dTddV2(i) = 0.0
     dTddV3(i) = 0.0
     dTdCD1(i) = 0.0
     dTdCD2(i) = 0.0
     dTdCD3(i) = 0.0
     dTdWf1(i) = 0.0
     dTdWf2(i) = 0.0
     dTdWf3(i) = 0.0
     dTdAlpha1(i) = 0.0
     dTdAlpha2(i) = 0.0
     dTdAlpha3(i) = 0.0
     dTdThrust1(i) = 0.0
     dTdThrust2(i) = 0.0
     dTdThrust3(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*vTemp(j)**2*dRhoTemp1(j)*S
        dQTempdRho2(j) = 0.5*vTemp(j)**2*dRhoTemp2(j)*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax
     
     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     dSinGamma1 = cos(gammaTemp)*dGammaTemp1
     dSinGamma2 = cos(gammaTemp)*dGammaTemp2
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)
     
     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        dCDTemp1(j) = R1(j)
        dCDTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dTdS(i) = dTdS(i)+R1(j)*xTemp(j)*(dQTempdS(j)*CDTemp(j))
        dTdWac(i) = dTdWac(i)+R1(j)*xTemp(j)*(dWTempdWac(j)*sinGamma(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdV2(i) = dTdV2(i)+R1(j)*xTemp(j)*(dQTempdV1(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dVTemp1(j))
        dTdV3(i) = dTdV3(i)+R1(j)*xTemp(j)*(dQTempdV2(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dvTemp2(j))
        dTdRho2(i) = dTdRho2(i)+R1(j)*xTemp(j)*(dQTempdRho1(j)*CDTemp(j))
        dTdRho3(i) = dTdRho3(i)+R1(j)*xTemp(j)*(dQTempdRho2(j)*CDTemp(j))
        dTdGamma2(i) = dTdGamma2(i)+R1(j)*xTemp(j)*(WTemp(j)*dSinGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma1(j)*dvTemp(j))
        dTdGamma3(i) = dTdGamma3(i)+R1(j)*xTemp(j)*(WTemp(j)*dSinGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma2(j)*dvTemp(j))
        dTddV2(i) = dTddV2(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp1(j))
        dTddV3(i) = dTddV3(i)+R1(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp2(j))
        dTdCD2(i) = dTdCD2(i)+R1(j)*xTemp(j)*(QTemp(j)*dCDTemp1(j))
        dTdCD3(i) = dTdCD3(i)+R1(j)*xTemp(j)*(QTemp(j)*dCDTemp2(j))
        dTdWf2(i) = dTdWf2(i)+R1(j)*xTemp(j)*(dWTempdWf1(j)*sinGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdWf3(i) = dTdWf3(i)+R1(j)*xTemp(j)*(dWTempdWf2(j)*sinGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdAlpha2(i) = dTdAlpha2(i)+R1(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp1(j))
        dTdAlpha3(i) = dTdAlpha3(i)+R1(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp2(j))
        dTdThrust2(i) = dTdThrust2(i)+R1(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp1(j))
        dTdThrust3(i) = dTdThrust3(i)+R1(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp2(j))
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     dSinGamma1 = cos(gammaTemp)*dGammaTemp1
     dSinGamma2 = cos(gammaTemp)*dGammaTemp2
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        dCDTemp1(j) = R1(j)
        dCDTemp2(j) = R2(j)
        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        dWTempdWf1(j) = R1(j)
        dWTempdWf2(j) = R2(j)
        dWTempdWac(j) = 1.0
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        dATemp1(j) = R1(j)
        dATemp2(j) = R2(j)
        tTemp(j) = Thrust(i)*R1(j) + Thrust(i+1)*R2(j)
        dTTemp1(j) = R1(j)
        dTTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dTdS(i+1) = dTdS(i+1)+R2(j)*xTemp(j)*(dQTempdS(j)*CDTemp(j))
        dTdWac(i+1) = dTdWac(i+1)+R2(j)*xTemp(j)*(dWTempdWac(j)*sinGamma(j) &
             +dWTempdWac(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdV1(i+1) = dTdV1(i+1)+R2(j)*xTemp(j)*(dQTempdV1(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dVTemp1(j))
        dTdV2(i+1) = dTdV2(i+1)+R2(j)*xTemp(j)*(dQTempdV2(j)*CDTemp(j) &
             +WTemp(j)*(1/g)*cosGamma(j)*dvTemp(j)*dvTemp2(j))
        dTdRho1(i+1) = dTdRho1(i+1)+R2(j)*xTemp(j)*(dQTempdRho1(j)*CDTemp(j))
        dTdRho2(i+1) = dTdRho2(i+1)+R2(j)*xTemp(j)*(dQTempdRho2(j)*CDTemp(j))
        dTdGamma1(i+1) = dTdGamma1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dSinGamma1(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma1(j)*dvTemp(j))
        dTdGamma2(i+1) = dTdGamma2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*dSinGamma2(j) &
             +WTemp(j)*(1/g)*vTemp(j)*dCosGamma2(j)*dvTemp(j))
        dTddV1(i+1) = dTddV1(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp1(j))
        dTddV2(i+1) = dTddV2(i+1)+R2(j)*xTemp(j)*(WTemp(j)*(1/g)*vTemp(j) &
             *cosGamma(j)*ddVTemp2(j))
        dTdCD1(i+1) = dTdCD1(i+1)+R2(j)*xTemp(j)*(QTemp(j)*dCDTemp1(j))
        dTdCD2(i+1) = dTdCD2(i+1)+R2(j)*xTemp(j)*(QTemp(j)*dCDTemp2(j))
        dTdWf1(i+1) = dTdWf1(i+1)+R2(j)*xTemp(j)*(dWTempdWf1(j)*sinGamma(j) &
             +dWTempdWf1(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdWf2(i+1) = dTdWf2(i+1)+R2(j)*xTemp(j)*(dWTempdWf2(j)*sinGamma(j) &
             +dWTempdWf2(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j))
        dTdAlpha1(i+1) = dTdAlpha1(i+1)+R2(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp1(j))
        dTdAlpha2(i+1) = dTdAlpha2(i+1)+R2(j)*xTemp(j)*(sin(aTemp(j))*tTemp(j) &
             *dATemp2(j))
        dTdThrust1(i+1) = dTdThrust1(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp1(j))
        dTdThrust2(i+1) = dTdThrust2(i+1)+R2(j)*xTemp(j)*(-cos(aTemp(k))*dTTemp2(j))
     enddo
  enddo
end subroutine getDThrust

subroutine getCMRes(numSeg, numInt, S, chord, inertia, x, v, rho, gamma, &
     dGamma, d2Gamma, dv, CM, CMRes)
  ! compute the residuals of eta by integrating the moment flight equation

  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, chord, inertia
  !f2py intent(in) x, v, rho, gamma, dGamma, d2Gamma, dv, CM
  !f2py intent(out) CMRes
  !f2py depend(numSeg) x, v, rho, gamma, dGamma, d2Gamma, dv, CM, CMRes

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, chord, inertia
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dGamma
  double precision, dimension(0:numSeg-1), intent(in) :: d2Gamma, dv, CM
  double precision, dimension(0:numSeg-1), intent(out) :: CMRes

  integer :: i = 0, j = 0, k = 0
  double precision :: temp, dx
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: d2GammaTemp, dvTemp, CMTemp
  double precision, dimension(0:numSeg-1,0:numInt-1) :: etaTemp

  do i = 0,numSeg-1
     do j = 0,numInt-1
        etaTemp(i,j) = 0.0
     enddo
     CMRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)
  
  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*(vTemp(j)*cosGamma(j))
        temp = temp+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*cosGamma(j)
        temp = temp*(-inertia)
        temp = temp+QTemp(j)*chord*CMTemp(j)
        temp = temp*R1(j)*xTemp(j)
        etaTemp(i,j) = etaTemp(i,j) + temp
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx
     
     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
     enddo

     do j = 0,numInt-1
        temp = d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*(vTemp(j)*cosGamma(j))
        temp = temp+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*cosGamma(j)
        temp = temp*(-inertia)
        temp = temp+QTemp(j)*chord*CMTemp(j)
        temp = temp*R2(j)*xTemp(j)
        etaTemp(i+1,j) = etaTemp(i+1,j) + temp
     enddo
  enddo

  do i = 0,numSeg-1
     do j = 0,numInt-1
        CMRes(i) = CMRes(i) + etaTemp(i,j)
     enddo
  enddo

end subroutine getCMRes

subroutine getDCM(numSeg, numInt, S, chord, inertia, x, v, rho, gamma, &
     dGamma, d2Gamma, dv, CM, dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, &
     dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, &
     dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3)
  ! compute the derivatives of residuals of eta wrt S, chord,
  ! inertia, v, rho, gamma, dgamma/dx, d2gamma/dx2, dv/dx, CM
  ! the jacobians are tri-diagonal, and are stored in 3 vectors
  
  !f2py intent(in) numSeg, numInt
  !f2py intent(in) S, chord, inertia
  !f2py intent(in) x, v, rho, gamma, dGamma, d2Gamma, dv, CM
  !f2py intent(out) dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3
  !f2py depend(numSeg) x, v, rho, gamma, dGamma, d2Gamma, dv, CM, dCMdS, dCMdC, dCMdI, dCMdV1, dCMdV2, dCMdV3, dCMdRho1, dCMdRho2, dCMdRho3, dCMdGamma1, dCMdGamma2, dCMdGamma3, dCMddGamma1, dCMddGamma2, dCMddGamma3, dCMdd2Gamma1, dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1, dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, intent(in) :: S, chord, inertia
  double precision, dimension(0:numSeg-1), intent(in) :: x, v, rho, gamma, dGamma
  double precision, dimension(0:numSeg-1), intent(in) :: d2Gamma, dv, CM
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdS, dCMdC, dCMdI
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdV1, dCMdV2, dCMdV3, dCMdRho1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdRho2, dCMdRho3, dCMdGamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdGamma2, dCMdGamma3, dCMddGamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMddGamma2, dCMddGamma3, dCMdd2Gamma1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMdd2Gamma2, dCMdd2Gamma3, dCMddV1
  double precision, dimension(0:numSeg-1), intent(out) :: dCMddV2, dCMddV3, dCMdCM1, dCMdCM2, dCMdCM3

  integer :: i = 0, j = 0, k = 0
  double precision :: deltax
  double precision, parameter :: param_zero = 0.0, param_one = 1.0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: xTemp, vTemp, rhoTemp, QTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, dGammaTemp
  double precision, dimension(0:numInt-1) :: d2GammaTemp, dvTemp, CMTemp
  double precision, dimension(0:numInt-1) :: dRhoTemp1, dRhoTemp2, dVTemp1
  double precision, dimension(0:numInt-1) :: dVTemp2, dQTempdRho1, dQTempdRho2
  double precision, dimension(0:numInt-1) :: dQTempdV1, dQTempdV2, dQTempdS
  double precision, dimension(0:numInt-1) :: dGammaTemp1, dGammaTemp2
  double precision, dimension(0:numInt-1) :: dCosGamma1, dCosGamma2
  double precision, dimension(0:numInt-1) :: ddGammaTemp1, ddGammaTemp2
  double precision, dimension(0:numInt-1) :: dd2GammaTemp1, dd2GammaTemp2
  double precision, dimension(0:numInt-1) :: ddVTemp1, ddVTemp2, dCMTemp1, dCMTemp2
  
  do i = 0,numSeg-1
     dCMdS(i) = 0.0
     dCMdC(i) = 0.0
     dCMdI(i) = 0.0
     dCMdV1(i) = 0.0
     dCMdV2(i) = 0.0
     dCMdV3(i) = 0.0
     dCMdRho1(i) = 0.0
     dCMdRho2(i) = 0.0
     dCMdRho3(i) = 0.0
     dCMdGamma1(i) = 0.0
     dCMdGamma2(i) = 0.0
     dCMdGamma3(i) = 0.0
     dCMddGamma1(i) = 0.0
     dCMddGamma2(i) = 0.0
     dCMddGamma3(i) = 0.0
     dCMdd2Gamma1(i) = 0.0
     dCMdd2Gamma2(i) = 0.0
     dCMdd2Gamma3(i) = 0.0
     dCMddV1(i) = 0.0
     dCMddV2(i) = 0.0
     dCMddV3(i) = 0.0
     dCMdCM1(i) = 0.0
     dCMdCM2(i) = 0.0
     dCMdCM3(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     call dlinspace(numInt, d2Gamma(i), d2Gamma(i+1), dd2GammaTemp1, dd2GammaTemp2)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
        dCMTemp1(j) = R1(j)
        dCMTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCMdS(i) = dCMdS(i)+R1(j)*xTemp(j)*(dQTempdS(j)*chord*CMTemp(j))
        dCMdC(i) = dCMdC(i)+R1(j)*xTemp(j)*(QTemp(j)*CMTemp(j))
        dCMdI(i) = dCMdI(i)+R1(j)*xTemp(j)*(-(d2GammaTemp(j)*(vTemp(j) &
             *cosGamma(j))**2+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2))
        dCMdV2(i) = dCMdV2(i)+R1(j)*xTemp(j)*(dQTempdV1(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp1(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp1(j)))
        dCMdV3(i) = dCMdV3(i)+R1(j)*xTemp(j)*(dQTempdV2(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp2(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp2(j)))
        dCMdRho2(i) = dCMdRho2(i)+R1(j)*xTemp(j)*(dQTempdRho1(j)*chord*CMTemp(j))
        dCMdRho3(i) = dCMdRho3(i)+R1(j)*xTemp(j)*(dQTempdRho2(j)*chord*CMTemp(j))
        dCMdGamma2(i) = dCMdGamma2(i)+R1(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma1(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma1(j))
        dCMdGamma3(i) = dCMdGamma3(i)+R1(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma2(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma2(j))
        dCMddGamma2(i) = dCMddGamma2(i)+R1(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp1(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMddGamma3(i) = dCMddGamma3(i)+R1(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp2(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMdd2Gamma2(i) = dCMdd2Gamma2(i)+R1(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp1(j)*(vTemp(j)*cosGamma(j))**2
        dCMdd2Gamma3(i) = dCMdd2Gamma3(i)+R1(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp2(j)*(vTemp(j)*cosGamma(j))**2
        dCMddV2(i) = dCMddV2(i)+R1(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp1(j)*vTemp(j)*cosGamma(j)**2
        dCMddV3(i) = dCMddV3(i)+R1(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp2(j)*vTemp(j)*cosGamma(j)**2
        dCMdCM2(i) = dCMdCM2(i)+R1(j)*xTemp(j)*QTemp(j)*chord*dCMTemp1(j)
        dCMdCM3(i) = dCMdCM3(i)+R1(j)*xTemp(j)*QTemp(j)*chord*dCMTemp2(j)
     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     call dlinspace(numInt, rho(i), rho(i+1), dRhoTemp1, dRhoTemp2)
     call dlinspace(numInt, v(i), v(i+1), dVTemp1, dVTemp2)
     deltax = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)**2*S
        dQTempdRho1(j) = 0.5*dRhoTemp1(j)*vTemp(j)**2*S
        dQTempdRho2(j) = 0.5*dRhoTemp2(j)*vTemp(j)**2*S
        dQTempdV1(j) = rhoTemp(j)*vTemp(j)*dVTemp1(j)*S
        dQTempdV2(j) = rhoTemp(j)*vTemp(j)*dVTemp2(j)*S
        dQTempdS(j) = 0.5*rhoTemp(j)*vTemp(j)**2
        xTemp(j) = deltax
     enddo

     xTemp(0) = 0.5*deltax
     xTemp(numInt-1) = 0.5*deltax
     
     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     call dlinspace(numInt, gamma(i), gamma(i+1), dGammaTemp1, dGammaTemp2)
     cosGamma = cos(gammaTemp)
     dCosGamma1 = -sin(gammaTemp)*dGammaTemp1
     dCosGamma2 = -sin(gammaTemp)*dGammaTemp2
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     call dlinspace(numInt, dGamma(i), dGamma(i+1), ddGammaTemp1, ddGammaTemp2)
     call dlinspace(numInt, d2Gamma(i), d2Gamma(i+1), dd2GammaTemp1, dd2GammaTemp2)
     call dlinspace(numInt, dv(i), dv(i+1), ddVTemp1, ddVTemp2)

     do j = 0,numInt-1
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)
        dCMTemp1(j) = R1(j)
        dCMTemp2(j) = R2(j)
     enddo

     do j = 0,numInt-1
        dCMdS(i+1) = dCMdS(i+1)+R2(j)*xTemp(j)*(dQTempdS(j)*chord*CMTemp(j))
        dCMdC(i+1) = dCMdC(i+1)+R2(j)*xTemp(j)*(QTemp(j)*CMTemp(j))
        dCMdI(i+1) = dCMdI(i+1)+R2(j)*xTemp(j)*(-(d2GammaTemp(j)*(vTemp(j) &
             *cosGamma(j))**2+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2))
        dCMdV1(i+1) = dCMdV1(i+1)+R2(j)*xTemp(j)*(dQTempdV1(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp1(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp1(j)))
        dCMdV2(i+1) = dCMdV2(i+1)+R2(j)*xTemp(j)*(dQTempdV2(j)*chord*CMTemp(j) &
             -inertia*(dGammaTemp(j)*dvTemp(j)*dVTemp2(j)*cosGamma(j)**2 &
             +2*d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*dVTemp2(j)))
        dCMdRho1(i+1) = dCMdRho1(i+1)+R2(j)*xTemp(j)*(dQTempdRho1(j)*chord*CMTemp(j))
        dCMdRho2(i+1) = dCMdRho2(i+1)+R2(j)*xTemp(j)*(dQTempdRho2(j)*chord*CMTemp(j))
        dCMdGamma1(i+1) = dCMdGamma1(i+1)+R2(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma1(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma1(j))
        dCMdGamma2(i+1) = dCMdGamma2(i+1)+R2(j)*xTemp(j)*2*(-inertia) &
             *(d2GammaTemp(j)*vTemp(j)**2*cosGamma(j)*dCosGamma2(j) &
             +dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*dCosGamma2(j))
        dCMddGamma1(i+1) = dCMddGamma1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp1(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMddGamma2(i+1) = dCMddGamma2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *ddGammaTemp2(j)*dvTemp(j)*vTemp(j)*cosGamma(j)**2
        dCMdd2Gamma1(i+1) = dCMdd2Gamma1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp1(j)*(vTemp(j)*cosGamma(j))**2
        dCMdd2Gamma2(i+1) = dCMdd2Gamma2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dd2GammaTemp2(j)*(vTemp(j)*cosGamma(j))**2
        dCMddV1(i+1) = dCMddV1(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp1(j)*vTemp(j)*cosGamma(j)**2
        dCMddV2(i+1) = dCMddV2(i+1)+R2(j)*xTemp(j)*(-inertia) &
             *dGammaTemp(j)*ddVTemp2(j)*vTemp(j)*cosGamma(j)**2
        dCMdCM1(i+1) = dCMdCM1(i+1)+R2(j)*xTemp(j)*QTemp(j)*chord*dCMTemp1(j)
        dCMdCM2(i+1) = dCMdCM2(i+1)+R2(j)*xTemp(j)*QTemp(j)*chord*dCMTemp2(j)
     enddo
  enddo

end subroutine getDCM

subroutine getFlightResF(numSeg, numInt, rho, v, x, gamma, dGamma, d2Gamma, dv &
     ,CL, CD, CM, Wf, tau, alpha, cThrust, S, Wac, g, chord, inertia, flightRes)

  !f2py intent(in) numSeg, numInt
  !f2py intent(in) rho, v, x, gamma, dGamma, d2Gamma, dv, CL, CD, CM, Wf, tau, alpha, cThrust
  !f2py intent(in) S, Wac, g, chord, inertia
  !f2py intent(out) flightRes
  !f2py depend(numSeg) rho, v, x, gamma, dGamma, d2Gamma, dv, CL, CD, CM, Wf, tau, alpha, cThrust, flightRes

  !Input/Output
  integer, intent(in) :: numSeg, numInt
  double precision, dimension(0:numSeg-1), intent(in) :: rho, v, x, gamma, dGamma, d2Gamma, dv, CL, CD, CM, Wf, tau, alpha, cThrust
  double precision, intent(in) :: S, Wac, g, chord, inertia
  double precision, dimension(0:3*numSeg-1), intent(out) :: flightRes

  integer :: i = 0, j = 0, k = 0
  double precision, dimension(0:numInt-1) :: R1, R2
  double precision, dimension(0:numInt-1) :: rhoTemp, vTemp, QTemp, xTemp
  double precision, dimension(0:numInt-1) :: gammaTemp, cosGamma, sinGamma
  double precision, dimension(0:numInt-1) :: dGammaTemp, d2GammaTemp, dvTemp
  double precision, dimension(0:numInt-1) :: CLTemp, CDTemp, CMTemp, WTemp
  double precision, dimension(0:numInt-1) :: aTemp, tTemp, cThrustTemp
  double precision :: tempFlight
  double precision, dimension(0:3*numSeg-1,0:numInt-1) :: flight
  double precision :: param_zero = 0.0, param_one = 1.0

  do i = 0,3*numSeg-1
     do j = 0,numInt-1
        flight(i,j) = 0.0
     enddo
     flightRes(i) = 0.0
  enddo

  call linspace(numInt, param_one, param_zero, R1)
  call linspace(numInt, param_zero, param_one, R2)

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt

     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)

     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)
     
     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j) + CL(i+1)*R2(j)
        CDTemp(j) = CD(i)*R1(j) + CD(i+1)*R2(j)
        CMTemp(j) = CM(i)*R1(j) + CM(i+1)*R2(j)

        WTemp(j) = Wac + Wf(i)*R1(j) + Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j) + alpha(i+1)*R2(j)
        tTemp(j) = tau(i)*R1(j) + tau(i+1)*R2(j)
     enddo

     call linspace(numInt, cThrust(i), cThrust(i+1), cThrustTemp)

     do j = 0,numInt-1
        tempFlight = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        tempFlight = tempFlight-cThrustTemp(j)*sin(aTemp(j))*tTemp(j)
        tempFlight = tempFlight+WTemp(j)*(1/g)*vTemp(j)*vTemp(j)*cosGamma(j)*dGammaTemp(j)
        tempFlight = tempFlight*R1(j)*xTemp(j)
        flight(i*3,j) = flight(i*3,j) + tempFlight

        tempFlight = (-cThrustTemp(j)*cos(aTemp(j))*tTemp(j))
        tempFlight = tempFlight+QTemp(j)*CDTemp(j)
        tempFlight = tempFlight+WTemp(j)*sinGamma(j)
        tempFlight = tempFlight+WTemp(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j)
        tempFlight = tempFlight*R1(j)*xTemp(j)
        flight(i*3+1,j) = flight(i*3+1,j) + tempFlight

        tempFlight = d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*(vTemp(j)*cosGamma(j))
        tempFlight = tempFlight+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*cosGamma(j)
        tempFlight = tempFlight*(-inertia)
        tempFlight = tempFlight+QTemp(j)*chord*CMTemp(j)
        tempFlight = tempFlight*R1(j)*xTemp(j)
        flight(i*3+2,j) = flight(i*3+2,j) + tempFlight

     enddo
  enddo

  do i = 0,numSeg-2
     call linspace(numInt, rho(i), rho(i+1), rhoTemp)
     call linspace(numInt, v(i), v(i+1), vTemp)
     dx = (x(i+1)-x(i))/numInt
     
     do j = 0,numInt-1
        QTemp(j) = 0.5*rhoTemp(j)*vTemp(j)*vTemp(j)*S
        xTemp(j) = dx
     enddo

     xTemp(0) = 0.5*dx
     xTemp(numInt-1) = 0.5*dx

     call linspace(numInt, gamma(i), gamma(i+1), gammaTemp)
     cosGamma = cos(gammaTemp)
     sinGamma = sin(gammaTemp)
     call linspace(numInt, dGamma(i), dGamma(i+1), dGammaTemp)
     call linspace(numInt, d2Gamma(i), d2Gamma(i+1), d2GammaTemp)
     call linspace(numInt, dv(i), dv(i+1), dvTemp)

     do j = 0,numInt-1
        CLTemp(j) = CL(i)*R1(j)+CL(i+1)*R2(j)
        CDTemp(j) = CD(i)*R1(j)+CD(i+1)*R2(j)
        CMTemp(j) = CM(i)*R1(j)+CM(i+1)*R2(j)

        WTemp(j) = Wac+Wf(i)*R1(j)+Wf(i+1)*R2(j)
        aTemp(j) = alpha(i)*R1(j)+alpha(i+1)*R2(j)
        tTemp(j) = tau(i)*R1(j)+tau(i+1)*R2(j)
        call linspace(numInt, cThrust(i), cThrust(i+1), cThrustTemp)
     enddo

     do j = 0,numInt-1
        tempFlight = (-QTemp(j)*CLTemp(j)+WTemp(j)*cosGamma(j))
        tempFlight = tempFlight-cThrustTemp(j)*sin(aTemp(j))*tTemp(j)
        tempFlight = tempFlight+WTemp(j)*(1/g)*vTemp(j)*vTemp(j)*cosGamma(j)*dGammaTemp(j)
        tempFlight = tempFlight*R2(j)*xTemp(j)
        flight((i+1)*3,j) = flight((i+1)*3,j) + tempFlight

        tempFlight = (-cThrustTemp(j)*cos(aTemp(j))*tTemp(j)+QTemp(j)*CDTemp(j))
        tempFlight = tempFlight+WTemp(j)*sinGamma(j)+WTemp(j)*(1/g)*vTemp(j)*cosGamma(j)*dvTemp(j)
        tempFlight = tempFlight*R2(j)*xTemp(j)
        flight((i+1)*3+1,j) = flight((i+1)*3+1,j) + tempFlight

        tempFlight = d2GammaTemp(j)*(vTemp(j)*cosGamma(j))*(vTemp(j)*cosGamma(j))
        tempFlight = tempFlight+dGammaTemp(j)*dvTemp(j)*vTemp(j)*cosGamma(j)*cosGamma(j)
        tempFlight = tempFlight*(-inertia)
        tempFlight = tempFlight+QTemp(j)*chord*CMTemp(j)
        tempFlight = tempFlight*R2(j)*xTemp(j)
        flight((i+1)*3+2,j) = flight((i+1)*3+2,j) + tempFlight
     enddo
  enddo

  do i = 0,3*numSeg-1
     do j = 0,numInt-1
        flightRes(i) = flightRes(i) + flight(i,j)
     enddo
  enddo

end subroutine getFlightResF
     
